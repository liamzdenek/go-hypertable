// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package Client

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

type ClientService interface { //The client service mimics the C++ client API, with table, scanner and
	//mutator interface flattened.

	// Create a namespace
	//
	// @param ns - namespace name
	//
	// Parameters:
	//  - Ns
	NamespaceCreate(ns string) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	CreateNamespace(ns string) (e *ClientException, err error)
	// Create a table
	//
	// @param ns - namespace id
	// @param table_name - table name
	// @param schema - schema of the table (in xml)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Schema
	CreateTable(ns Namespace, table_name string, schema string) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Schema
	TableCreate(ns Namespace, table_name string, schema string) (e *ClientException, err error)
	// Alter a table
	//
	// @param ns - namespace id
	// @param table_name - table name
	// @param schema - schema of the table (in xml)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Schema
	AlterTable(ns Namespace, table_name string, schema string) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Schema
	TableAlter(ns Namespace, table_name string, schema string) (e *ClientException, err error)
	// Refreshes the cached table information
	//
	// @param ns - namespace
	// @param table_name - name of the table
	//
	// Parameters:
	//  - Ns
	//  - TableName
	RefreshTable(ns Namespace, table_name string) (e *ClientException, err error)
	// Open a namespace
	//
	// @param ns - namespace
	// @return value is guaranteed to be non-zero and unique
	//
	// Parameters:
	//  - Ns
	NamespaceOpen(ns string) (r Namespace, e *ClientException, err error)
	// Parameters:
	//  - Ns
	OpenNamespace(ns string) (r Namespace, e *ClientException, err error)
	// Close a namespace
	//
	// @param ns - namespace
	//
	// Parameters:
	//  - Ns
	NamespaceClose(ns Namespace) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	CloseNamespace(ns Namespace) (e *ClientException, err error)
	// Open a future object
	// @param capacity - Amount of result data the future object can enqueue without blocking threads
	//
	// Parameters:
	//  - Capacity
	FutureOpen(capacity int32) (r Future, e *ClientException, err error)
	// Parameters:
	//  - Capacity
	OpenFuture(capacity int32) (r Future, e *ClientException, err error)
	// Cancel tasks outstanding in a future object
	// @param ff - Future object
	//
	// Parameters:
	//  - Ff
	FutureCancel(ff Future) (e *ClientException, err error)
	// Parameters:
	//  - Ff
	CancelFuture(ff Future) (e *ClientException, err error)
	// Fetch asynchronous results
	// @param ff - Future object which has the asynchronous results
	// @return - result from async scanner/mutator
	//
	// Parameters:
	//  - Ff
	//  - TimeoutMillis
	FutureGetResult(ff Future, timeout_millis int32) (r *Result, e *ClientException, err error)
	// Parameters:
	//  - Ff
	//  - TimeoutMillis
	GetFutureResult(ff Future, timeout_millis int32) (r *Result, e *ClientException, err error)
	// Fetch asynchronous results
	// @param ff - Future object which has the asynchronous results
	// @return - result from async scanner/mutator
	//
	// Parameters:
	//  - Ff
	//  - TimeoutMillis
	FutureGetResultAsArrays(ff Future, timeout_millis int32) (r *ResultAsArrays, e *ClientException, err error)
	// Parameters:
	//  - Ff
	//  - TimeoutMillis
	GetFutureResultAsArrays(ff Future, timeout_millis int32) (r *ResultAsArrays, e *ClientException, err error)
	// Fetch asynchronous results
	// @param ff - Future object which has the asynchronous results
	// @return - result from async scanner/mutator
	//
	// Parameters:
	//  - Ff
	//  - TimeoutMillis
	FutureGetResultSerialized(ff Future, timeout_millis int32) (r *ResultSerialized, e *ClientException, err error)
	// Parameters:
	//  - Ff
	//  - TimeoutMillis
	GetFutureResultSerialized(ff Future, timeout_millis int32) (r *ResultSerialized, e *ClientException, err error)
	// Check if future object's queue is empty
	//
	// Parameters:
	//  - Ff
	FutureIsEmpty(ff Future) (r bool, e *ClientException, err error)
	// Check if future object's queue is full
	//
	// Parameters:
	//  - Ff
	FutureIsFull(ff Future) (r bool, e *ClientException, err error)
	// Check if future object has been cancelled
	//
	// Parameters:
	//  - Ff
	FutureIsCancelled(ff Future) (r bool, e *ClientException, err error)
	// Check if future object has outstanding operations
	//
	// Parameters:
	//  - Ff
	FutureHasOutstanding(ff Future) (r bool, e *ClientException, err error)
	// Close a future object
	// @param ff - the future object to be closed
	//
	// Parameters:
	//  - Ff
	FutureClose(ff Future) (e *ClientException, err error)
	// Parameters:
	//  - Ff
	CloseFuture(ff Future) (e *ClientException, err error)
	// Open a table scanner
	// @param ns - namespace id
	// @param table_name - table name
	// @param scan_spec - scan specification
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - ScanSpec
	ScannerOpen(ns Namespace, table_name string, scan_spec *ScanSpec) (r Scanner, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - ScanSpec
	OpenScanner(ns Namespace, table_name string, scan_spec *ScanSpec) (r Scanner, e *ClientException, err error)
	// Open an asynchronous table scanner
	// @param ns - namespace id
	// @param table_name - table name
	// @param future - callback object
	// @param scan_spec - scan specification
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Future
	//  - ScanSpec
	AsyncScannerOpen(ns Namespace, table_name string, future Future, scan_spec *ScanSpec) (r ScannerAsync, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Future
	//  - ScanSpec
	OpenScannerAsync(ns Namespace, table_name string, future Future, scan_spec *ScanSpec) (r ScannerAsync, e *ClientException, err error)
	// Close a table scanner
	//
	// @param scanner - scanner id to close
	//
	// Parameters:
	//  - Scanner
	ScannerClose(scanner Scanner) (e *ClientException, err error)
	// Parameters:
	//  - Scanner
	CloseScanner(scanner Scanner) (e *ClientException, err error)
	// Cancel a table scanner
	//
	// @param scanner - scanner id to close
	//
	// Parameters:
	//  - Scanner
	AsyncScannerCancel(scanner ScannerAsync) (e *ClientException, err error)
	// Parameters:
	//  - Scanner
	CancelScannerAsync(scanner ScannerAsync) (e *ClientException, err error)
	// Close a table scanner
	//
	// @param scanner - scanner id to close
	//
	// Parameters:
	//  - Scanner
	AsyncScannerClose(scanner ScannerAsync) (e *ClientException, err error)
	// Parameters:
	//  - Scanner
	CloseScannerAsync(scanner ScannerAsync) (e *ClientException, err error)
	// Iterate over cells of a scanner
	//
	// @param scanner - scanner id
	//
	// Parameters:
	//  - Scanner
	ScannerGetCells(scanner Scanner) (r []*Cell, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	NextCells(scanner Scanner) (r []*Cell, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	ScannerGetCellsAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	NextCellsAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error)
	// Alternative interface returning buffer of serialized cells
	//
	// Parameters:
	//  - Scanner
	ScannerGetCellsSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	NextCellsSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error)
	// Iterate over rows of a scanner
	//
	// @param scanner - scanner id
	//
	// Parameters:
	//  - Scanner
	ScannerGetRow(scanner Scanner) (r []*Cell, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	NextRow(scanner Scanner) (r []*Cell, e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Scanner
	ScannerGetRowAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	NextRowAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error)
	// Alternate interface returning a buffer of serialized cells for iterating by row
	// for a given scanner
	//
	// @param scanner - scanner id
	//
	// Parameters:
	//  - Scanner
	ScannerGetRowSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error)
	// Parameters:
	//  - Scanner
	NextRowSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error)
	// Get a row (convenience method for random access a row)
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param row - row key
	//
	// @return a list of cells (with row_keys unset)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Row
	GetRow(ns Namespace, table_name string, row string) (r []*Cell, e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Ns
	//  - Name
	//  - Row
	GetRowAsArrays(ns Namespace, name string, row string) (r []CellAsArray, e *ClientException, err error)
	// Alternative interface returning buffer of serialized cells
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Row
	GetRowSerialized(ns Namespace, table_name string, row string) (r CellsSerialized, e *ClientException, err error)
	// Get a cell (convenience method for random access a cell)
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param row - row key
	//
	// @param column - column name
	//
	// @return value (byte sequence)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Row
	//  - Column
	GetCell(ns Namespace, table_name string, row string, column string) (r Value, e *ClientException, err error)
	// Get cells (convenience method for access small amount of cells)
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param scan_spec - scan specification
	//
	// @return a list of cells (a cell with no row key set is assumed to have
	//         the same row key as the previous cell)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - ScanSpec
	GetCells(ns Namespace, table_name string, scan_spec *ScanSpec) (r []*Cell, e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Ns
	//  - Name
	//  - ScanSpec
	GetCellsAsArrays(ns Namespace, name string, scan_spec *ScanSpec) (r []CellAsArray, e *ClientException, err error)
	// Alternative interface returning buffer of serialized cells
	//
	// Parameters:
	//  - Ns
	//  - Name
	//  - ScanSpec
	GetCellsSerialized(ns Namespace, name string, scan_spec *ScanSpec) (r CellsSerialized, e *ClientException, err error)
	// Create a shared mutator with specified MutateSpec.
	// Delete and recreate it if the mutator exists.
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param mutate_spec - mutator specification
	//
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	SharedMutatorRefresh(ns Namespace, table_name string, mutate_spec *MutateSpec) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	RefreshSharedMutator(ns Namespace, table_name string, mutate_spec *MutateSpec) (e *ClientException, err error)
	// Open a shared periodic mutator which causes cells to be written asyncronously.
	// Users beware: calling this method merely writes
	// cells to a local buffer and does not guarantee that the cells have been persisted.
	// If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param mutate_spec - mutator specification
	//
	// @param cells - set of cells to be written
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cells
	SharedMutatorSetCells(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []*Cell) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cells
	OfferCells(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []*Cell) (e *ClientException, err error)
	// Alternative to offer_cell interface using array as cell
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cells
	SharedMutatorSetCellsAsArrays(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []CellAsArray) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cells
	OfferCellsAsArrays(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []CellAsArray) (e *ClientException, err error)
	// Open a shared periodic mutator which causes cells to be written asyncronously.
	// Users beware: calling this method merely writes
	// cells to a local buffer and does not guarantee that the cells have been persisted.
	// If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param mutate_spec - mutator specification
	//
	// @param cell - cell to be written
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cell
	SharedMutatorSetCell(ns Namespace, table_name string, mutate_spec *MutateSpec, cell *Cell) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cell
	OfferCell(ns Namespace, table_name string, mutate_spec *MutateSpec, cell *Cell) (e *ClientException, err error)
	// Alternative to offer_cell interface using array as cell
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cell
	SharedMutatorSetCellAsArray(ns Namespace, table_name string, mutate_spec *MutateSpec, cell CellAsArray) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - MutateSpec
	//  - Cell
	OfferCellAsArray(ns Namespace, table_name string, mutate_spec *MutateSpec, cell CellAsArray) (e *ClientException, err error)
	// Open a table mutator
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param flags - mutator flags
	//
	// @param flush_interval - auto-flush interval in milliseconds; 0 disables it.
	//
	// @return mutator id
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Flags
	//  - FlushInterval
	MutatorOpen(ns Namespace, table_name string, flags int32, flush_interval int32) (r Mutator, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Flags
	//  - FlushInterval
	OpenMutator(ns Namespace, table_name string, flags int32, flush_interval int32) (r Mutator, e *ClientException, err error)
	// Open an asynchronous table mutator
	//
	// @param ns - namespace id
	// @param table_name - table name
	// @param future - callback object
	// @param flags - mutator flags
	//
	// @return mutator id
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Future
	//  - Flags
	AsyncMutatorOpen(ns Namespace, table_name string, future Future, flags int32) (r MutatorAsync, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Future
	//  - Flags
	OpenMutatorAsync(ns Namespace, table_name string, future Future, flags int32) (r MutatorAsync, e *ClientException, err error)
	// Close a table mutator
	//
	// @param mutator - mutator id to close
	//
	// Parameters:
	//  - Mutator
	MutatorClose(mutator Mutator) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	CloseMutator(mutator Mutator) (e *ClientException, err error)
	// Cancel an asynchronous table mutator
	//
	// @param mutator -  mutator id to cancel
	//
	// Parameters:
	//  - Mutator
	AsyncMutatorCancel(mutator MutatorAsync) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	CancelMutatorAsync(mutator MutatorAsync) (e *ClientException, err error)
	// Close an asynchronous table mutator
	//
	// @param mutator - mutator id to close
	//
	// Parameters:
	//  - Mutator
	AsyncMutatorClose(mutator MutatorAsync) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	CloseMutatorAsync(mutator MutatorAsync) (e *ClientException, err error)
	// Set a cell via mutator
	//
	// @param mutator - mutator id
	//
	// @param cell - the cell to set
	//
	// Parameters:
	//  - Mutator
	//  - Cell
	MutatorSetCell(mutator Mutator, cell *Cell) (e *ClientException, err error)
	// Set a cell in the table
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param cell - the cell to set
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Cell
	SetCell(ns Namespace, table_name string, cell *Cell) (e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Mutator
	//  - Cell
	MutatorSetCellAsArray(mutator Mutator, cell CellAsArray) (e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Cell
	SetCellAsArray(ns Namespace, table_name string, cell CellAsArray) (e *ClientException, err error)
	// Put a list of cells into a table via mutator
	//
	// @param mutator - mutator id
	//
	// @param cells - a list of cells (a cell with no row key set is assumed
	//        to have the same row key as the previous cell)
	//
	// Parameters:
	//  - Mutator
	//  - Cells
	MutatorSetCells(mutator Mutator, cells []*Cell) (e *ClientException, err error)
	// Put a list of cells into a table
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @param cells - a list of cells (a cell with no row key set is assumed
	//        to have the same row key as the previous cell)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Cells
	SetCells(ns Namespace, table_name string, cells []*Cell) (e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Mutator
	//  - Cells
	MutatorSetCellsAsArrays(mutator Mutator, cells []CellAsArray) (e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Cells
	SetCellsAsArrays(ns Namespace, table_name string, cells []CellAsArray) (e *ClientException, err error)
	// Alternative interface using buffer of serialized cells
	//
	// Parameters:
	//  - Mutator
	//  - Cells
	//  - Flush
	MutatorSetCellsSerialized(mutator Mutator, cells CellsSerialized, flush bool) (e *ClientException, err error)
	// Alternative interface using buffer of serialized cells
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Cells
	SetCellsSerialized(ns Namespace, table_name string, cells CellsSerialized) (e *ClientException, err error)
	// Flush mutator buffers
	//
	// Parameters:
	//  - Mutator
	MutatorFlush(mutator Mutator) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	FlushMutator(mutator Mutator) (e *ClientException, err error)
	// Set a cell in the table using an asynchonous mutator
	//
	// @param mutator - mutator id
	//
	// @param cell - the cell to set
	//
	// Parameters:
	//  - Mutator
	//  - Cell
	AsyncMutatorSetCell(mutator MutatorAsync, cell *Cell) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	//  - Cell
	SetCellAsync(mutator MutatorAsync, cell *Cell) (e *ClientException, err error)
	// Alternative interface using array as cell using an asynchonous mutator
	//
	// Parameters:
	//  - Mutator
	//  - Cell
	AsyncMutatorSetCellAsArray(mutator MutatorAsync, cell CellAsArray) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	//  - Cell
	SetCellAsArrayAsync(mutator MutatorAsync, cell CellAsArray) (e *ClientException, err error)
	// Put a list of cells into a table using asynchonous mutator
	//
	// @param mutator - mutator id
	//
	// @param cells - a list of cells (a cell with no row key set is assumed
	//        to have the same row key as the previous cell)
	//
	// Parameters:
	//  - Mutator
	//  - Cells
	AsyncMutatorSetCells(mutator MutatorAsync, cells []*Cell) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	//  - Cells
	SetCellsAsync(mutator MutatorAsync, cells []*Cell) (e *ClientException, err error)
	// Alternative interface using array as cell
	//
	// Parameters:
	//  - Mutator
	//  - Cells
	AsyncMutatorSetCellsAsArrays(mutator MutatorAsync, cells []CellAsArray) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	//  - Cells
	SetCellsAsArraysAsync(mutator MutatorAsync, cells []CellAsArray) (e *ClientException, err error)
	// Alternative interface using buffer of serialized cells
	//
	// Parameters:
	//  - Mutator
	//  - Cells
	//  - Flush
	AsyncMutatorSetCellsSerialized(mutator MutatorAsync, cells CellsSerialized, flush bool) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	//  - Cells
	//  - Flush
	SetCellsSerializedAsync(mutator MutatorAsync, cells CellsSerialized, flush bool) (e *ClientException, err error)
	// Flush mutator buffers
	//
	// Parameters:
	//  - Mutator
	AsyncMutatorFlush(mutator MutatorAsync) (e *ClientException, err error)
	// Parameters:
	//  - Mutator
	FlushMutatorAsync(mutator MutatorAsync) (e *ClientException, err error)
	// Check if the namespace exists
	//
	// @param ns - namespace name
	//
	// @return true if ns exists, false ow
	//
	// Parameters:
	//  - Ns
	NamespaceExists(ns string) (r bool, e *ClientException, err error)
	// Parameters:
	//  - Ns
	ExistsNamespace(ns string) (r bool, e *ClientException, err error)
	// Check if the table exists
	//
	// @param ns - namespace id
	//
	// @param name - table name
	//
	// @return true if table exists, false ow
	//
	// Parameters:
	//  - Ns
	//  - Name
	ExistsTable(ns Namespace, name string) (r bool, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - Name
	TableExists(ns Namespace, name string) (r bool, e *ClientException, err error)
	// Get the id of a table
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @return table id string
	//
	// Parameters:
	//  - Ns
	//  - TableName
	TableGetId(ns Namespace, table_name string) (r string, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	GetTableId(ns Namespace, table_name string) (r string, e *ClientException, err error)
	// Get the schema of a table as a string (that can be used with create_table)
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @return schema string (in xml)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	TableGetSchemaStr(ns Namespace, table_name string) (r string, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	GetSchemaStr(ns Namespace, table_name string) (r string, e *ClientException, err error)
	// Get the schema of a table as a string along with column family ids
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @return schema string (in xml)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	TableGetSchemaStrWithIds(ns Namespace, table_name string) (r string, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	GetSchemaStrWithIds(ns Namespace, table_name string) (r string, e *ClientException, err error)
	// Get the schema of a table as a string (that can be used with create_table)
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @return schema object describing a table
	//
	// Parameters:
	//  - Ns
	//  - TableName
	TableGetSchema(ns Namespace, table_name string) (r *Schema, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	GetSchema(ns Namespace, table_name string) (r *Schema, e *ClientException, err error)
	// Get a list of table names in the namespace
	//
	// @param ns - namespace id
	//
	// @return a list of table names
	//
	// Parameters:
	//  - Ns
	GetTables(ns Namespace) (r []string, e *ClientException, err error)
	// Get a list of namespaces and table names table names in the namespace
	//
	// @param ns - namespace
	//
	// @return a list of table names
	//
	// Parameters:
	//  - Ns
	NamespaceGetListing(ns Namespace) (r []*NamespaceListing, e *ClientException, err error)
	// Parameters:
	//  - Ns
	GetListing(ns Namespace) (r []*NamespaceListing, e *ClientException, err error)
	// Get a list of table splits
	//
	// @param ns - namespace id
	//
	// @param table_name - table name
	//
	// @return a list of table names
	//
	// Parameters:
	//  - Ns
	//  - TableName
	TableGetSplits(ns Namespace, table_name string) (r []*TableSplit, e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - TableName
	GetTableSplits(ns Namespace, table_name string) (r []*TableSplit, e *ClientException, err error)
	// Drop a namespace
	//
	// @param ns - namespace name
	//
	// @param if_exists - if true, don't barf if the table doesn't exist
	//
	// Parameters:
	//  - Ns
	//  - IfExists
	NamespaceDrop(ns string, if_exists bool) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - IfExists
	DropNamespace(ns string, if_exists bool) (e *ClientException, err error)
	// Rename a table
	//
	// @param ns - namespace id
	//
	// @param name - current table name
	//
	// @param new_name - new table name
	//
	// Parameters:
	//  - Ns
	//  - Name
	//  - NewName
	RenameTable(ns Namespace, name string, new_name string) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - Name
	//  - NewName
	TableRename(ns Namespace, name string, new_name string) (e *ClientException, err error)
	// Drop a table
	//
	// @param ns - namespace id
	//
	// @param name - table name
	//
	// @param if_exists - if true, don't barf if the table doesn't exist
	//
	// Parameters:
	//  - Ns
	//  - Name
	//  - IfExists
	DropTable(ns Namespace, name string, if_exists bool) (e *ClientException, err error)
	// Parameters:
	//  - Ns
	//  - Name
	//  - IfExists
	TableDrop(ns Namespace, name string, if_exists bool) (e *ClientException, err error)
	// Generate a GUID
	//
	// GUIDs are globally unique. The generated string is 36 bytes long and
	// has a format similar to "9cf7da31-307a-4bef-b65e-19fb05aa57d8".
	GenerateGuid() (r string, err error)
	// Inserts a unique value into a table
	//
	// This function inserts a unique value into a table. The table must be
	// created with TIME_ORDER DESC, MAX_VERSIONS 1 (although the latter is
	// optional).
	//
	// If the value is empty then a new GUID will be assigned
	// (using @a generate_guid).
	//
	// @param ns - namespace id
	// @param table_name - table name
	// @param key - the Key of the value
	// @param value - the unique value. Can be empty; in this case a new
	//    guid will be generated internally
	//
	// @return the inserted unique value (which is identical to the @a value
	//    parameter or a new guid, if value is empty)
	//
	// Parameters:
	//  - Ns
	//  - TableName
	//  - Key
	//  - Value
	CreateCellUnique(ns Namespace, table_name string, key *Key, value string) (r string, e *ClientException, err error)
	// Retrieves a descriptive error string from an error code
	//
	// @param error_code - the numeric error code
	//
	// @return the descriptive string, or "ERROR NOT REGISTERED" if the error
	//    code is unknown
	//
	// Parameters:
	//  - ErrorCode
	ErrorGetText(error_code int32) (r string, err error)
}

//The client service mimics the C++ client API, with table, scanner and
//mutator interface flattened.
type ClientServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewClientServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ClientServiceClient {
	return &ClientServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewClientServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ClientServiceClient {
	return &ClientServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Create a namespace
//
// @param ns - namespace name
//
// Parameters:
//  - Ns
func (p *ClientServiceClient) NamespaceCreate(ns string) (e *ClientException, err error) {
	if err = p.sendNamespaceCreate(ns); err != nil {
		return
	}
	return p.recvNamespaceCreate()
}

func (p *ClientServiceClient) sendNamespaceCreate(ns string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("namespace_create", thrift.CALL, p.SeqId)
	args12 := NewNamespaceCreateArgs()
	args12.Ns = ns
	err = args12.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNamespaceCreate() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error14 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error15 error
		error15, err = error14.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error15
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result13 := NewNamespaceCreateResult()
	err = result13.Read(iprot)
	iprot.ReadMessageEnd()
	if result13.E != nil {
		e = result13.E
	}
	return
}

// Parameters:
//  - Ns
func (p *ClientServiceClient) CreateNamespace(ns string) (e *ClientException, err error) {
	if err = p.sendCreateNamespace(ns); err != nil {
		return
	}
	return p.recvCreateNamespace()
}

func (p *ClientServiceClient) sendCreateNamespace(ns string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("create_namespace", thrift.CALL, p.SeqId)
	args16 := NewCreateNamespaceArgs()
	args16.Ns = ns
	err = args16.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCreateNamespace() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error18 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error19 error
		error19, err = error18.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error19
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result17 := NewCreateNamespaceResult()
	err = result17.Read(iprot)
	iprot.ReadMessageEnd()
	if result17.E != nil {
		e = result17.E
	}
	return
}

// Create a table
//
// @param ns - namespace id
// @param table_name - table name
// @param schema - schema of the table (in xml)
//
// Parameters:
//  - Ns
//  - TableName
//  - Schema
func (p *ClientServiceClient) CreateTable(ns Namespace, table_name string, schema string) (e *ClientException, err error) {
	if err = p.sendCreateTable(ns, table_name, schema); err != nil {
		return
	}
	return p.recvCreateTable()
}

func (p *ClientServiceClient) sendCreateTable(ns Namespace, table_name string, schema string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("create_table", thrift.CALL, p.SeqId)
	args20 := NewCreateTableArgs()
	args20.Ns = ns
	args20.TableName = table_name
	args20.Schema = schema
	err = args20.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCreateTable() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error22 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error23 error
		error23, err = error22.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error23
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result21 := NewCreateTableResult()
	err = result21.Read(iprot)
	iprot.ReadMessageEnd()
	if result21.E != nil {
		e = result21.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - Schema
func (p *ClientServiceClient) TableCreate(ns Namespace, table_name string, schema string) (e *ClientException, err error) {
	if err = p.sendTableCreate(ns, table_name, schema); err != nil {
		return
	}
	return p.recvTableCreate()
}

func (p *ClientServiceClient) sendTableCreate(ns Namespace, table_name string, schema string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_create", thrift.CALL, p.SeqId)
	args24 := NewTableCreateArgs()
	args24.Ns = ns
	args24.TableName = table_name
	args24.Schema = schema
	err = args24.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableCreate() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error26 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error27 error
		error27, err = error26.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error27
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result25 := NewTableCreateResult()
	err = result25.Read(iprot)
	iprot.ReadMessageEnd()
	if result25.E != nil {
		e = result25.E
	}
	return
}

// Alter a table
//
// @param ns - namespace id
// @param table_name - table name
// @param schema - schema of the table (in xml)
//
// Parameters:
//  - Ns
//  - TableName
//  - Schema
func (p *ClientServiceClient) AlterTable(ns Namespace, table_name string, schema string) (e *ClientException, err error) {
	if err = p.sendAlterTable(ns, table_name, schema); err != nil {
		return
	}
	return p.recvAlterTable()
}

func (p *ClientServiceClient) sendAlterTable(ns Namespace, table_name string, schema string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("alter_table", thrift.CALL, p.SeqId)
	args28 := NewAlterTableArgs()
	args28.Ns = ns
	args28.TableName = table_name
	args28.Schema = schema
	err = args28.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAlterTable() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error30 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error31 error
		error31, err = error30.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error31
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result29 := NewAlterTableResult()
	err = result29.Read(iprot)
	iprot.ReadMessageEnd()
	if result29.E != nil {
		e = result29.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - Schema
func (p *ClientServiceClient) TableAlter(ns Namespace, table_name string, schema string) (e *ClientException, err error) {
	if err = p.sendTableAlter(ns, table_name, schema); err != nil {
		return
	}
	return p.recvTableAlter()
}

func (p *ClientServiceClient) sendTableAlter(ns Namespace, table_name string, schema string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_alter", thrift.CALL, p.SeqId)
	args32 := NewTableAlterArgs()
	args32.Ns = ns
	args32.TableName = table_name
	args32.Schema = schema
	err = args32.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableAlter() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result33 := NewTableAlterResult()
	err = result33.Read(iprot)
	iprot.ReadMessageEnd()
	if result33.E != nil {
		e = result33.E
	}
	return
}

// Refreshes the cached table information
//
// @param ns - namespace
// @param table_name - name of the table
//
// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) RefreshTable(ns Namespace, table_name string) (e *ClientException, err error) {
	if err = p.sendRefreshTable(ns, table_name); err != nil {
		return
	}
	return p.recvRefreshTable()
}

func (p *ClientServiceClient) sendRefreshTable(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("refresh_table", thrift.CALL, p.SeqId)
	args36 := NewRefreshTableArgs()
	args36.Ns = ns
	args36.TableName = table_name
	err = args36.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvRefreshTable() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result37 := NewRefreshTableResult()
	err = result37.Read(iprot)
	iprot.ReadMessageEnd()
	if result37.E != nil {
		e = result37.E
	}
	return
}

// Open a namespace
//
// @param ns - namespace
// @return value is guaranteed to be non-zero and unique
//
// Parameters:
//  - Ns
func (p *ClientServiceClient) NamespaceOpen(ns string) (r Namespace, e *ClientException, err error) {
	if err = p.sendNamespaceOpen(ns); err != nil {
		return
	}
	return p.recvNamespaceOpen()
}

func (p *ClientServiceClient) sendNamespaceOpen(ns string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("namespace_open", thrift.CALL, p.SeqId)
	args40 := NewNamespaceOpenArgs()
	args40.Ns = ns
	err = args40.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNamespaceOpen() (value Namespace, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result41 := NewNamespaceOpenResult()
	err = result41.Read(iprot)
	iprot.ReadMessageEnd()
	value = result41.Success
	if result41.E != nil {
		e = result41.E
	}
	return
}

// Parameters:
//  - Ns
func (p *ClientServiceClient) OpenNamespace(ns string) (r Namespace, e *ClientException, err error) {
	if err = p.sendOpenNamespace(ns); err != nil {
		return
	}
	return p.recvOpenNamespace()
}

func (p *ClientServiceClient) sendOpenNamespace(ns string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("open_namespace", thrift.CALL, p.SeqId)
	args44 := NewOpenNamespaceArgs()
	args44.Ns = ns
	err = args44.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOpenNamespace() (value Namespace, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result45 := NewOpenNamespaceResult()
	err = result45.Read(iprot)
	iprot.ReadMessageEnd()
	value = result45.Success
	if result45.E != nil {
		e = result45.E
	}
	return
}

// Close a namespace
//
// @param ns - namespace
//
// Parameters:
//  - Ns
func (p *ClientServiceClient) NamespaceClose(ns Namespace) (e *ClientException, err error) {
	if err = p.sendNamespaceClose(ns); err != nil {
		return
	}
	return p.recvNamespaceClose()
}

func (p *ClientServiceClient) sendNamespaceClose(ns Namespace) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("namespace_close", thrift.CALL, p.SeqId)
	args48 := NewNamespaceCloseArgs()
	args48.Ns = ns
	err = args48.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNamespaceClose() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error50 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error51 error
		error51, err = error50.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error51
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result49 := NewNamespaceCloseResult()
	err = result49.Read(iprot)
	iprot.ReadMessageEnd()
	if result49.E != nil {
		e = result49.E
	}
	return
}

// Parameters:
//  - Ns
func (p *ClientServiceClient) CloseNamespace(ns Namespace) (e *ClientException, err error) {
	if err = p.sendCloseNamespace(ns); err != nil {
		return
	}
	return p.recvCloseNamespace()
}

func (p *ClientServiceClient) sendCloseNamespace(ns Namespace) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("close_namespace", thrift.CALL, p.SeqId)
	args52 := NewCloseNamespaceArgs()
	args52.Ns = ns
	err = args52.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCloseNamespace() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error54 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error55 error
		error55, err = error54.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error55
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result53 := NewCloseNamespaceResult()
	err = result53.Read(iprot)
	iprot.ReadMessageEnd()
	if result53.E != nil {
		e = result53.E
	}
	return
}

// Open a future object
// @param capacity - Amount of result data the future object can enqueue without blocking threads
//
// Parameters:
//  - Capacity
func (p *ClientServiceClient) FutureOpen(capacity int32) (r Future, e *ClientException, err error) {
	if err = p.sendFutureOpen(capacity); err != nil {
		return
	}
	return p.recvFutureOpen()
}

func (p *ClientServiceClient) sendFutureOpen(capacity int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_open", thrift.CALL, p.SeqId)
	args56 := NewFutureOpenArgs()
	args56.Capacity = capacity
	err = args56.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureOpen() (value Future, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error58 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error59 error
		error59, err = error58.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error59
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result57 := NewFutureOpenResult()
	err = result57.Read(iprot)
	iprot.ReadMessageEnd()
	value = result57.Success
	if result57.E != nil {
		e = result57.E
	}
	return
}

// Parameters:
//  - Capacity
func (p *ClientServiceClient) OpenFuture(capacity int32) (r Future, e *ClientException, err error) {
	if err = p.sendOpenFuture(capacity); err != nil {
		return
	}
	return p.recvOpenFuture()
}

func (p *ClientServiceClient) sendOpenFuture(capacity int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("open_future", thrift.CALL, p.SeqId)
	args60 := NewOpenFutureArgs()
	args60.Capacity = capacity
	err = args60.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOpenFuture() (value Future, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error62 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error63 error
		error63, err = error62.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error63
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result61 := NewOpenFutureResult()
	err = result61.Read(iprot)
	iprot.ReadMessageEnd()
	value = result61.Success
	if result61.E != nil {
		e = result61.E
	}
	return
}

// Cancel tasks outstanding in a future object
// @param ff - Future object
//
// Parameters:
//  - Ff
func (p *ClientServiceClient) FutureCancel(ff Future) (e *ClientException, err error) {
	if err = p.sendFutureCancel(ff); err != nil {
		return
	}
	return p.recvFutureCancel()
}

func (p *ClientServiceClient) sendFutureCancel(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_cancel", thrift.CALL, p.SeqId)
	args64 := NewFutureCancelArgs()
	args64.Ff = ff
	err = args64.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureCancel() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error66 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error67 error
		error67, err = error66.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error67
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result65 := NewFutureCancelResult()
	err = result65.Read(iprot)
	iprot.ReadMessageEnd()
	if result65.E != nil {
		e = result65.E
	}
	return
}

// Parameters:
//  - Ff
func (p *ClientServiceClient) CancelFuture(ff Future) (e *ClientException, err error) {
	if err = p.sendCancelFuture(ff); err != nil {
		return
	}
	return p.recvCancelFuture()
}

func (p *ClientServiceClient) sendCancelFuture(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("cancel_future", thrift.CALL, p.SeqId)
	args68 := NewCancelFutureArgs()
	args68.Ff = ff
	err = args68.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCancelFuture() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error70 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error71 error
		error71, err = error70.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error71
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result69 := NewCancelFutureResult()
	err = result69.Read(iprot)
	iprot.ReadMessageEnd()
	if result69.E != nil {
		e = result69.E
	}
	return
}

// Fetch asynchronous results
// @param ff - Future object which has the asynchronous results
// @return - result from async scanner/mutator
//
// Parameters:
//  - Ff
//  - TimeoutMillis
func (p *ClientServiceClient) FutureGetResult(ff Future, timeout_millis int32) (r *Result, e *ClientException, err error) {
	if err = p.sendFutureGetResult(ff, timeout_millis); err != nil {
		return
	}
	return p.recvFutureGetResult()
}

func (p *ClientServiceClient) sendFutureGetResult(ff Future, timeout_millis int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_get_result", thrift.CALL, p.SeqId)
	args72 := NewFutureGetResultArgs()
	args72.Ff = ff
	args72.TimeoutMillis = timeout_millis
	err = args72.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureGetResult() (value *Result, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error74 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error75 error
		error75, err = error74.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error75
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result73 := NewFutureGetResultResult()
	err = result73.Read(iprot)
	iprot.ReadMessageEnd()
	value = result73.Success
	if result73.E != nil {
		e = result73.E
	}
	return
}

// Parameters:
//  - Ff
//  - TimeoutMillis
func (p *ClientServiceClient) GetFutureResult(ff Future, timeout_millis int32) (r *Result, e *ClientException, err error) {
	if err = p.sendGetFutureResult(ff, timeout_millis); err != nil {
		return
	}
	return p.recvGetFutureResult()
}

func (p *ClientServiceClient) sendGetFutureResult(ff Future, timeout_millis int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_future_result", thrift.CALL, p.SeqId)
	args76 := NewGetFutureResultArgs()
	args76.Ff = ff
	args76.TimeoutMillis = timeout_millis
	err = args76.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetFutureResult() (value *Result, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error78 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error79 error
		error79, err = error78.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error79
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result77 := NewGetFutureResultResult()
	err = result77.Read(iprot)
	iprot.ReadMessageEnd()
	value = result77.Success
	if result77.E != nil {
		e = result77.E
	}
	return
}

// Fetch asynchronous results
// @param ff - Future object which has the asynchronous results
// @return - result from async scanner/mutator
//
// Parameters:
//  - Ff
//  - TimeoutMillis
func (p *ClientServiceClient) FutureGetResultAsArrays(ff Future, timeout_millis int32) (r *ResultAsArrays, e *ClientException, err error) {
	if err = p.sendFutureGetResultAsArrays(ff, timeout_millis); err != nil {
		return
	}
	return p.recvFutureGetResultAsArrays()
}

func (p *ClientServiceClient) sendFutureGetResultAsArrays(ff Future, timeout_millis int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_get_result_as_arrays", thrift.CALL, p.SeqId)
	args80 := NewFutureGetResultAsArraysArgs()
	args80.Ff = ff
	args80.TimeoutMillis = timeout_millis
	err = args80.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureGetResultAsArrays() (value *ResultAsArrays, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error82 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error83 error
		error83, err = error82.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error83
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result81 := NewFutureGetResultAsArraysResult()
	err = result81.Read(iprot)
	iprot.ReadMessageEnd()
	value = result81.Success
	if result81.E != nil {
		e = result81.E
	}
	return
}

// Parameters:
//  - Ff
//  - TimeoutMillis
func (p *ClientServiceClient) GetFutureResultAsArrays(ff Future, timeout_millis int32) (r *ResultAsArrays, e *ClientException, err error) {
	if err = p.sendGetFutureResultAsArrays(ff, timeout_millis); err != nil {
		return
	}
	return p.recvGetFutureResultAsArrays()
}

func (p *ClientServiceClient) sendGetFutureResultAsArrays(ff Future, timeout_millis int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_future_result_as_arrays", thrift.CALL, p.SeqId)
	args84 := NewGetFutureResultAsArraysArgs()
	args84.Ff = ff
	args84.TimeoutMillis = timeout_millis
	err = args84.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetFutureResultAsArrays() (value *ResultAsArrays, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error86 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error87 error
		error87, err = error86.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error87
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result85 := NewGetFutureResultAsArraysResult()
	err = result85.Read(iprot)
	iprot.ReadMessageEnd()
	value = result85.Success
	if result85.E != nil {
		e = result85.E
	}
	return
}

// Fetch asynchronous results
// @param ff - Future object which has the asynchronous results
// @return - result from async scanner/mutator
//
// Parameters:
//  - Ff
//  - TimeoutMillis
func (p *ClientServiceClient) FutureGetResultSerialized(ff Future, timeout_millis int32) (r *ResultSerialized, e *ClientException, err error) {
	if err = p.sendFutureGetResultSerialized(ff, timeout_millis); err != nil {
		return
	}
	return p.recvFutureGetResultSerialized()
}

func (p *ClientServiceClient) sendFutureGetResultSerialized(ff Future, timeout_millis int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_get_result_serialized", thrift.CALL, p.SeqId)
	args88 := NewFutureGetResultSerializedArgs()
	args88.Ff = ff
	args88.TimeoutMillis = timeout_millis
	err = args88.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureGetResultSerialized() (value *ResultSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error90 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error91 error
		error91, err = error90.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error91
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result89 := NewFutureGetResultSerializedResult()
	err = result89.Read(iprot)
	iprot.ReadMessageEnd()
	value = result89.Success
	if result89.E != nil {
		e = result89.E
	}
	return
}

// Parameters:
//  - Ff
//  - TimeoutMillis
func (p *ClientServiceClient) GetFutureResultSerialized(ff Future, timeout_millis int32) (r *ResultSerialized, e *ClientException, err error) {
	if err = p.sendGetFutureResultSerialized(ff, timeout_millis); err != nil {
		return
	}
	return p.recvGetFutureResultSerialized()
}

func (p *ClientServiceClient) sendGetFutureResultSerialized(ff Future, timeout_millis int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_future_result_serialized", thrift.CALL, p.SeqId)
	args92 := NewGetFutureResultSerializedArgs()
	args92.Ff = ff
	args92.TimeoutMillis = timeout_millis
	err = args92.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetFutureResultSerialized() (value *ResultSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error94 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error95 error
		error95, err = error94.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error95
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result93 := NewGetFutureResultSerializedResult()
	err = result93.Read(iprot)
	iprot.ReadMessageEnd()
	value = result93.Success
	if result93.E != nil {
		e = result93.E
	}
	return
}

// Check if future object's queue is empty
//
// Parameters:
//  - Ff
func (p *ClientServiceClient) FutureIsEmpty(ff Future) (r bool, e *ClientException, err error) {
	if err = p.sendFutureIsEmpty(ff); err != nil {
		return
	}
	return p.recvFutureIsEmpty()
}

func (p *ClientServiceClient) sendFutureIsEmpty(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_is_empty", thrift.CALL, p.SeqId)
	args96 := NewFutureIsEmptyArgs()
	args96.Ff = ff
	err = args96.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureIsEmpty() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error98 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error99 error
		error99, err = error98.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error99
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result97 := NewFutureIsEmptyResult()
	err = result97.Read(iprot)
	iprot.ReadMessageEnd()
	value = result97.Success
	if result97.E != nil {
		e = result97.E
	}
	return
}

// Check if future object's queue is full
//
// Parameters:
//  - Ff
func (p *ClientServiceClient) FutureIsFull(ff Future) (r bool, e *ClientException, err error) {
	if err = p.sendFutureIsFull(ff); err != nil {
		return
	}
	return p.recvFutureIsFull()
}

func (p *ClientServiceClient) sendFutureIsFull(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_is_full", thrift.CALL, p.SeqId)
	args100 := NewFutureIsFullArgs()
	args100.Ff = ff
	err = args100.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureIsFull() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error102 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error103 error
		error103, err = error102.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error103
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result101 := NewFutureIsFullResult()
	err = result101.Read(iprot)
	iprot.ReadMessageEnd()
	value = result101.Success
	if result101.E != nil {
		e = result101.E
	}
	return
}

// Check if future object has been cancelled
//
// Parameters:
//  - Ff
func (p *ClientServiceClient) FutureIsCancelled(ff Future) (r bool, e *ClientException, err error) {
	if err = p.sendFutureIsCancelled(ff); err != nil {
		return
	}
	return p.recvFutureIsCancelled()
}

func (p *ClientServiceClient) sendFutureIsCancelled(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_is_cancelled", thrift.CALL, p.SeqId)
	args104 := NewFutureIsCancelledArgs()
	args104.Ff = ff
	err = args104.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureIsCancelled() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error106 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error107 error
		error107, err = error106.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error107
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result105 := NewFutureIsCancelledResult()
	err = result105.Read(iprot)
	iprot.ReadMessageEnd()
	value = result105.Success
	if result105.E != nil {
		e = result105.E
	}
	return
}

// Check if future object has outstanding operations
//
// Parameters:
//  - Ff
func (p *ClientServiceClient) FutureHasOutstanding(ff Future) (r bool, e *ClientException, err error) {
	if err = p.sendFutureHasOutstanding(ff); err != nil {
		return
	}
	return p.recvFutureHasOutstanding()
}

func (p *ClientServiceClient) sendFutureHasOutstanding(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_has_outstanding", thrift.CALL, p.SeqId)
	args108 := NewFutureHasOutstandingArgs()
	args108.Ff = ff
	err = args108.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureHasOutstanding() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error110 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error111 error
		error111, err = error110.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error111
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result109 := NewFutureHasOutstandingResult()
	err = result109.Read(iprot)
	iprot.ReadMessageEnd()
	value = result109.Success
	if result109.E != nil {
		e = result109.E
	}
	return
}

// Close a future object
// @param ff - the future object to be closed
//
// Parameters:
//  - Ff
func (p *ClientServiceClient) FutureClose(ff Future) (e *ClientException, err error) {
	if err = p.sendFutureClose(ff); err != nil {
		return
	}
	return p.recvFutureClose()
}

func (p *ClientServiceClient) sendFutureClose(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("future_close", thrift.CALL, p.SeqId)
	args112 := NewFutureCloseArgs()
	args112.Ff = ff
	err = args112.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFutureClose() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error114 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error115 error
		error115, err = error114.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error115
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result113 := NewFutureCloseResult()
	err = result113.Read(iprot)
	iprot.ReadMessageEnd()
	if result113.E != nil {
		e = result113.E
	}
	return
}

// Parameters:
//  - Ff
func (p *ClientServiceClient) CloseFuture(ff Future) (e *ClientException, err error) {
	if err = p.sendCloseFuture(ff); err != nil {
		return
	}
	return p.recvCloseFuture()
}

func (p *ClientServiceClient) sendCloseFuture(ff Future) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("close_future", thrift.CALL, p.SeqId)
	args116 := NewCloseFutureArgs()
	args116.Ff = ff
	err = args116.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCloseFuture() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error118 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error119 error
		error119, err = error118.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error119
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result117 := NewCloseFutureResult()
	err = result117.Read(iprot)
	iprot.ReadMessageEnd()
	if result117.E != nil {
		e = result117.E
	}
	return
}

// Open a table scanner
// @param ns - namespace id
// @param table_name - table name
// @param scan_spec - scan specification
//
// Parameters:
//  - Ns
//  - TableName
//  - ScanSpec
func (p *ClientServiceClient) ScannerOpen(ns Namespace, table_name string, scan_spec *ScanSpec) (r Scanner, e *ClientException, err error) {
	if err = p.sendScannerOpen(ns, table_name, scan_spec); err != nil {
		return
	}
	return p.recvScannerOpen()
}

func (p *ClientServiceClient) sendScannerOpen(ns Namespace, table_name string, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_open", thrift.CALL, p.SeqId)
	args120 := NewScannerOpenArgs()
	args120.Ns = ns
	args120.TableName = table_name
	args120.ScanSpec = scan_spec
	err = args120.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerOpen() (value Scanner, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error122 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error123 error
		error123, err = error122.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error123
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result121 := NewScannerOpenResult()
	err = result121.Read(iprot)
	iprot.ReadMessageEnd()
	value = result121.Success
	if result121.E != nil {
		e = result121.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - ScanSpec
func (p *ClientServiceClient) OpenScanner(ns Namespace, table_name string, scan_spec *ScanSpec) (r Scanner, e *ClientException, err error) {
	if err = p.sendOpenScanner(ns, table_name, scan_spec); err != nil {
		return
	}
	return p.recvOpenScanner()
}

func (p *ClientServiceClient) sendOpenScanner(ns Namespace, table_name string, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("open_scanner", thrift.CALL, p.SeqId)
	args124 := NewOpenScannerArgs()
	args124.Ns = ns
	args124.TableName = table_name
	args124.ScanSpec = scan_spec
	err = args124.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOpenScanner() (value Scanner, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error126 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error127 error
		error127, err = error126.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error127
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result125 := NewOpenScannerResult()
	err = result125.Read(iprot)
	iprot.ReadMessageEnd()
	value = result125.Success
	if result125.E != nil {
		e = result125.E
	}
	return
}

// Open an asynchronous table scanner
// @param ns - namespace id
// @param table_name - table name
// @param future - callback object
// @param scan_spec - scan specification
//
// Parameters:
//  - Ns
//  - TableName
//  - Future
//  - ScanSpec
func (p *ClientServiceClient) AsyncScannerOpen(ns Namespace, table_name string, future Future, scan_spec *ScanSpec) (r ScannerAsync, e *ClientException, err error) {
	if err = p.sendAsyncScannerOpen(ns, table_name, future, scan_spec); err != nil {
		return
	}
	return p.recvAsyncScannerOpen()
}

func (p *ClientServiceClient) sendAsyncScannerOpen(ns Namespace, table_name string, future Future, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_scanner_open", thrift.CALL, p.SeqId)
	args128 := NewAsyncScannerOpenArgs()
	args128.Ns = ns
	args128.TableName = table_name
	args128.Future = future
	args128.ScanSpec = scan_spec
	err = args128.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncScannerOpen() (value ScannerAsync, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error130 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error131 error
		error131, err = error130.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error131
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result129 := NewAsyncScannerOpenResult()
	err = result129.Read(iprot)
	iprot.ReadMessageEnd()
	value = result129.Success
	if result129.E != nil {
		e = result129.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - Future
//  - ScanSpec
func (p *ClientServiceClient) OpenScannerAsync(ns Namespace, table_name string, future Future, scan_spec *ScanSpec) (r ScannerAsync, e *ClientException, err error) {
	if err = p.sendOpenScannerAsync(ns, table_name, future, scan_spec); err != nil {
		return
	}
	return p.recvOpenScannerAsync()
}

func (p *ClientServiceClient) sendOpenScannerAsync(ns Namespace, table_name string, future Future, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("open_scanner_async", thrift.CALL, p.SeqId)
	args132 := NewOpenScannerAsyncArgs()
	args132.Ns = ns
	args132.TableName = table_name
	args132.Future = future
	args132.ScanSpec = scan_spec
	err = args132.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOpenScannerAsync() (value ScannerAsync, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error134 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error135 error
		error135, err = error134.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error135
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result133 := NewOpenScannerAsyncResult()
	err = result133.Read(iprot)
	iprot.ReadMessageEnd()
	value = result133.Success
	if result133.E != nil {
		e = result133.E
	}
	return
}

// Close a table scanner
//
// @param scanner - scanner id to close
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerClose(scanner Scanner) (e *ClientException, err error) {
	if err = p.sendScannerClose(scanner); err != nil {
		return
	}
	return p.recvScannerClose()
}

func (p *ClientServiceClient) sendScannerClose(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_close", thrift.CALL, p.SeqId)
	args136 := NewScannerCloseArgs()
	args136.Scanner = scanner
	err = args136.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerClose() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error138 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error139 error
		error139, err = error138.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error139
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result137 := NewScannerCloseResult()
	err = result137.Read(iprot)
	iprot.ReadMessageEnd()
	if result137.E != nil {
		e = result137.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) CloseScanner(scanner Scanner) (e *ClientException, err error) {
	if err = p.sendCloseScanner(scanner); err != nil {
		return
	}
	return p.recvCloseScanner()
}

func (p *ClientServiceClient) sendCloseScanner(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("close_scanner", thrift.CALL, p.SeqId)
	args140 := NewCloseScannerArgs()
	args140.Scanner = scanner
	err = args140.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCloseScanner() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error142 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error143 error
		error143, err = error142.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error143
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result141 := NewCloseScannerResult()
	err = result141.Read(iprot)
	iprot.ReadMessageEnd()
	if result141.E != nil {
		e = result141.E
	}
	return
}

// Cancel a table scanner
//
// @param scanner - scanner id to close
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) AsyncScannerCancel(scanner ScannerAsync) (e *ClientException, err error) {
	if err = p.sendAsyncScannerCancel(scanner); err != nil {
		return
	}
	return p.recvAsyncScannerCancel()
}

func (p *ClientServiceClient) sendAsyncScannerCancel(scanner ScannerAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_scanner_cancel", thrift.CALL, p.SeqId)
	args144 := NewAsyncScannerCancelArgs()
	args144.Scanner = scanner
	err = args144.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncScannerCancel() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error146 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error147 error
		error147, err = error146.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error147
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result145 := NewAsyncScannerCancelResult()
	err = result145.Read(iprot)
	iprot.ReadMessageEnd()
	if result145.E != nil {
		e = result145.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) CancelScannerAsync(scanner ScannerAsync) (e *ClientException, err error) {
	if err = p.sendCancelScannerAsync(scanner); err != nil {
		return
	}
	return p.recvCancelScannerAsync()
}

func (p *ClientServiceClient) sendCancelScannerAsync(scanner ScannerAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("cancel_scanner_async", thrift.CALL, p.SeqId)
	args148 := NewCancelScannerAsyncArgs()
	args148.Scanner = scanner
	err = args148.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCancelScannerAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error150 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error151 error
		error151, err = error150.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error151
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result149 := NewCancelScannerAsyncResult()
	err = result149.Read(iprot)
	iprot.ReadMessageEnd()
	if result149.E != nil {
		e = result149.E
	}
	return
}

// Close a table scanner
//
// @param scanner - scanner id to close
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) AsyncScannerClose(scanner ScannerAsync) (e *ClientException, err error) {
	if err = p.sendAsyncScannerClose(scanner); err != nil {
		return
	}
	return p.recvAsyncScannerClose()
}

func (p *ClientServiceClient) sendAsyncScannerClose(scanner ScannerAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_scanner_close", thrift.CALL, p.SeqId)
	args152 := NewAsyncScannerCloseArgs()
	args152.Scanner = scanner
	err = args152.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncScannerClose() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error154 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error155 error
		error155, err = error154.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error155
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result153 := NewAsyncScannerCloseResult()
	err = result153.Read(iprot)
	iprot.ReadMessageEnd()
	if result153.E != nil {
		e = result153.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) CloseScannerAsync(scanner ScannerAsync) (e *ClientException, err error) {
	if err = p.sendCloseScannerAsync(scanner); err != nil {
		return
	}
	return p.recvCloseScannerAsync()
}

func (p *ClientServiceClient) sendCloseScannerAsync(scanner ScannerAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("close_scanner_async", thrift.CALL, p.SeqId)
	args156 := NewCloseScannerAsyncArgs()
	args156.Scanner = scanner
	err = args156.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCloseScannerAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error158 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error159 error
		error159, err = error158.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error159
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result157 := NewCloseScannerAsyncResult()
	err = result157.Read(iprot)
	iprot.ReadMessageEnd()
	if result157.E != nil {
		e = result157.E
	}
	return
}

// Iterate over cells of a scanner
//
// @param scanner - scanner id
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerGetCells(scanner Scanner) (r []*Cell, e *ClientException, err error) {
	if err = p.sendScannerGetCells(scanner); err != nil {
		return
	}
	return p.recvScannerGetCells()
}

func (p *ClientServiceClient) sendScannerGetCells(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_get_cells", thrift.CALL, p.SeqId)
	args160 := NewScannerGetCellsArgs()
	args160.Scanner = scanner
	err = args160.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerGetCells() (value []*Cell, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error162 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error163 error
		error163, err = error162.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error163
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result161 := NewScannerGetCellsResult()
	err = result161.Read(iprot)
	iprot.ReadMessageEnd()
	value = result161.Success
	if result161.E != nil {
		e = result161.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) NextCells(scanner Scanner) (r []*Cell, e *ClientException, err error) {
	if err = p.sendNextCells(scanner); err != nil {
		return
	}
	return p.recvNextCells()
}

func (p *ClientServiceClient) sendNextCells(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("next_cells", thrift.CALL, p.SeqId)
	args164 := NewNextCellsArgs()
	args164.Scanner = scanner
	err = args164.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNextCells() (value []*Cell, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error166 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error167 error
		error167, err = error166.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error167
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result165 := NewNextCellsResult()
	err = result165.Read(iprot)
	iprot.ReadMessageEnd()
	value = result165.Success
	if result165.E != nil {
		e = result165.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerGetCellsAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error) {
	if err = p.sendScannerGetCellsAsArrays(scanner); err != nil {
		return
	}
	return p.recvScannerGetCellsAsArrays()
}

func (p *ClientServiceClient) sendScannerGetCellsAsArrays(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_get_cells_as_arrays", thrift.CALL, p.SeqId)
	args168 := NewScannerGetCellsAsArraysArgs()
	args168.Scanner = scanner
	err = args168.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerGetCellsAsArrays() (value []CellAsArray, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error170 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error171 error
		error171, err = error170.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error171
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result169 := NewScannerGetCellsAsArraysResult()
	err = result169.Read(iprot)
	iprot.ReadMessageEnd()
	value = result169.Success
	if result169.E != nil {
		e = result169.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) NextCellsAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error) {
	if err = p.sendNextCellsAsArrays(scanner); err != nil {
		return
	}
	return p.recvNextCellsAsArrays()
}

func (p *ClientServiceClient) sendNextCellsAsArrays(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("next_cells_as_arrays", thrift.CALL, p.SeqId)
	args172 := NewNextCellsAsArraysArgs()
	args172.Scanner = scanner
	err = args172.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNextCellsAsArrays() (value []CellAsArray, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error174 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error175 error
		error175, err = error174.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error175
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result173 := NewNextCellsAsArraysResult()
	err = result173.Read(iprot)
	iprot.ReadMessageEnd()
	value = result173.Success
	if result173.E != nil {
		e = result173.E
	}
	return
}

// Alternative interface returning buffer of serialized cells
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerGetCellsSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error) {
	if err = p.sendScannerGetCellsSerialized(scanner); err != nil {
		return
	}
	return p.recvScannerGetCellsSerialized()
}

func (p *ClientServiceClient) sendScannerGetCellsSerialized(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_get_cells_serialized", thrift.CALL, p.SeqId)
	args176 := NewScannerGetCellsSerializedArgs()
	args176.Scanner = scanner
	err = args176.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerGetCellsSerialized() (value CellsSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error178 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error179 error
		error179, err = error178.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error179
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result177 := NewScannerGetCellsSerializedResult()
	err = result177.Read(iprot)
	iprot.ReadMessageEnd()
	value = result177.Success
	if result177.E != nil {
		e = result177.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) NextCellsSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error) {
	if err = p.sendNextCellsSerialized(scanner); err != nil {
		return
	}
	return p.recvNextCellsSerialized()
}

func (p *ClientServiceClient) sendNextCellsSerialized(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("next_cells_serialized", thrift.CALL, p.SeqId)
	args180 := NewNextCellsSerializedArgs()
	args180.Scanner = scanner
	err = args180.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNextCellsSerialized() (value CellsSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error182 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error183 error
		error183, err = error182.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error183
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result181 := NewNextCellsSerializedResult()
	err = result181.Read(iprot)
	iprot.ReadMessageEnd()
	value = result181.Success
	if result181.E != nil {
		e = result181.E
	}
	return
}

// Iterate over rows of a scanner
//
// @param scanner - scanner id
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerGetRow(scanner Scanner) (r []*Cell, e *ClientException, err error) {
	if err = p.sendScannerGetRow(scanner); err != nil {
		return
	}
	return p.recvScannerGetRow()
}

func (p *ClientServiceClient) sendScannerGetRow(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_get_row", thrift.CALL, p.SeqId)
	args184 := NewScannerGetRowArgs()
	args184.Scanner = scanner
	err = args184.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerGetRow() (value []*Cell, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error186 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error187 error
		error187, err = error186.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error187
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result185 := NewScannerGetRowResult()
	err = result185.Read(iprot)
	iprot.ReadMessageEnd()
	value = result185.Success
	if result185.E != nil {
		e = result185.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) NextRow(scanner Scanner) (r []*Cell, e *ClientException, err error) {
	if err = p.sendNextRow(scanner); err != nil {
		return
	}
	return p.recvNextRow()
}

func (p *ClientServiceClient) sendNextRow(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("next_row", thrift.CALL, p.SeqId)
	args188 := NewNextRowArgs()
	args188.Scanner = scanner
	err = args188.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNextRow() (value []*Cell, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error190 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error191 error
		error191, err = error190.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error191
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result189 := NewNextRowResult()
	err = result189.Read(iprot)
	iprot.ReadMessageEnd()
	value = result189.Success
	if result189.E != nil {
		e = result189.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerGetRowAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error) {
	if err = p.sendScannerGetRowAsArrays(scanner); err != nil {
		return
	}
	return p.recvScannerGetRowAsArrays()
}

func (p *ClientServiceClient) sendScannerGetRowAsArrays(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_get_row_as_arrays", thrift.CALL, p.SeqId)
	args192 := NewScannerGetRowAsArraysArgs()
	args192.Scanner = scanner
	err = args192.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerGetRowAsArrays() (value []CellAsArray, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error194 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error195 error
		error195, err = error194.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error195
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result193 := NewScannerGetRowAsArraysResult()
	err = result193.Read(iprot)
	iprot.ReadMessageEnd()
	value = result193.Success
	if result193.E != nil {
		e = result193.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) NextRowAsArrays(scanner Scanner) (r []CellAsArray, e *ClientException, err error) {
	if err = p.sendNextRowAsArrays(scanner); err != nil {
		return
	}
	return p.recvNextRowAsArrays()
}

func (p *ClientServiceClient) sendNextRowAsArrays(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("next_row_as_arrays", thrift.CALL, p.SeqId)
	args196 := NewNextRowAsArraysArgs()
	args196.Scanner = scanner
	err = args196.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNextRowAsArrays() (value []CellAsArray, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error198 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error199 error
		error199, err = error198.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error199
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result197 := NewNextRowAsArraysResult()
	err = result197.Read(iprot)
	iprot.ReadMessageEnd()
	value = result197.Success
	if result197.E != nil {
		e = result197.E
	}
	return
}

// Alternate interface returning a buffer of serialized cells for iterating by row
// for a given scanner
//
// @param scanner - scanner id
//
// Parameters:
//  - Scanner
func (p *ClientServiceClient) ScannerGetRowSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error) {
	if err = p.sendScannerGetRowSerialized(scanner); err != nil {
		return
	}
	return p.recvScannerGetRowSerialized()
}

func (p *ClientServiceClient) sendScannerGetRowSerialized(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("scanner_get_row_serialized", thrift.CALL, p.SeqId)
	args200 := NewScannerGetRowSerializedArgs()
	args200.Scanner = scanner
	err = args200.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvScannerGetRowSerialized() (value CellsSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error202 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error203 error
		error203, err = error202.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error203
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result201 := NewScannerGetRowSerializedResult()
	err = result201.Read(iprot)
	iprot.ReadMessageEnd()
	value = result201.Success
	if result201.E != nil {
		e = result201.E
	}
	return
}

// Parameters:
//  - Scanner
func (p *ClientServiceClient) NextRowSerialized(scanner Scanner) (r CellsSerialized, e *ClientException, err error) {
	if err = p.sendNextRowSerialized(scanner); err != nil {
		return
	}
	return p.recvNextRowSerialized()
}

func (p *ClientServiceClient) sendNextRowSerialized(scanner Scanner) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("next_row_serialized", thrift.CALL, p.SeqId)
	args204 := NewNextRowSerializedArgs()
	args204.Scanner = scanner
	err = args204.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNextRowSerialized() (value CellsSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error206 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error207 error
		error207, err = error206.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error207
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result205 := NewNextRowSerializedResult()
	err = result205.Read(iprot)
	iprot.ReadMessageEnd()
	value = result205.Success
	if result205.E != nil {
		e = result205.E
	}
	return
}

// Get a row (convenience method for random access a row)
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param row - row key
//
// @return a list of cells (with row_keys unset)
//
// Parameters:
//  - Ns
//  - TableName
//  - Row
func (p *ClientServiceClient) GetRow(ns Namespace, table_name string, row string) (r []*Cell, e *ClientException, err error) {
	if err = p.sendGetRow(ns, table_name, row); err != nil {
		return
	}
	return p.recvGetRow()
}

func (p *ClientServiceClient) sendGetRow(ns Namespace, table_name string, row string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_row", thrift.CALL, p.SeqId)
	args208 := NewGetRowArgs()
	args208.Ns = ns
	args208.TableName = table_name
	args208.Row = row
	err = args208.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetRow() (value []*Cell, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error210 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error211 error
		error211, err = error210.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error211
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result209 := NewGetRowResult()
	err = result209.Read(iprot)
	iprot.ReadMessageEnd()
	value = result209.Success
	if result209.E != nil {
		e = result209.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Ns
//  - Name
//  - Row
func (p *ClientServiceClient) GetRowAsArrays(ns Namespace, name string, row string) (r []CellAsArray, e *ClientException, err error) {
	if err = p.sendGetRowAsArrays(ns, name, row); err != nil {
		return
	}
	return p.recvGetRowAsArrays()
}

func (p *ClientServiceClient) sendGetRowAsArrays(ns Namespace, name string, row string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_row_as_arrays", thrift.CALL, p.SeqId)
	args212 := NewGetRowAsArraysArgs()
	args212.Ns = ns
	args212.Name = name
	args212.Row = row
	err = args212.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetRowAsArrays() (value []CellAsArray, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error214 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error215 error
		error215, err = error214.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error215
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result213 := NewGetRowAsArraysResult()
	err = result213.Read(iprot)
	iprot.ReadMessageEnd()
	value = result213.Success
	if result213.E != nil {
		e = result213.E
	}
	return
}

// Alternative interface returning buffer of serialized cells
//
// Parameters:
//  - Ns
//  - TableName
//  - Row
func (p *ClientServiceClient) GetRowSerialized(ns Namespace, table_name string, row string) (r CellsSerialized, e *ClientException, err error) {
	if err = p.sendGetRowSerialized(ns, table_name, row); err != nil {
		return
	}
	return p.recvGetRowSerialized()
}

func (p *ClientServiceClient) sendGetRowSerialized(ns Namespace, table_name string, row string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_row_serialized", thrift.CALL, p.SeqId)
	args216 := NewGetRowSerializedArgs()
	args216.Ns = ns
	args216.TableName = table_name
	args216.Row = row
	err = args216.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetRowSerialized() (value CellsSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error218 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error219 error
		error219, err = error218.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error219
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result217 := NewGetRowSerializedResult()
	err = result217.Read(iprot)
	iprot.ReadMessageEnd()
	value = result217.Success
	if result217.E != nil {
		e = result217.E
	}
	return
}

// Get a cell (convenience method for random access a cell)
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param row - row key
//
// @param column - column name
//
// @return value (byte sequence)
//
// Parameters:
//  - Ns
//  - TableName
//  - Row
//  - Column
func (p *ClientServiceClient) GetCell(ns Namespace, table_name string, row string, column string) (r Value, e *ClientException, err error) {
	if err = p.sendGetCell(ns, table_name, row, column); err != nil {
		return
	}
	return p.recvGetCell()
}

func (p *ClientServiceClient) sendGetCell(ns Namespace, table_name string, row string, column string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_cell", thrift.CALL, p.SeqId)
	args220 := NewGetCellArgs()
	args220.Ns = ns
	args220.TableName = table_name
	args220.Row = row
	args220.Column = column
	err = args220.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetCell() (value Value, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error222 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error223 error
		error223, err = error222.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error223
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result221 := NewGetCellResult()
	err = result221.Read(iprot)
	iprot.ReadMessageEnd()
	value = result221.Success
	if result221.E != nil {
		e = result221.E
	}
	return
}

// Get cells (convenience method for access small amount of cells)
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param scan_spec - scan specification
//
// @return a list of cells (a cell with no row key set is assumed to have
//         the same row key as the previous cell)
//
// Parameters:
//  - Ns
//  - TableName
//  - ScanSpec
func (p *ClientServiceClient) GetCells(ns Namespace, table_name string, scan_spec *ScanSpec) (r []*Cell, e *ClientException, err error) {
	if err = p.sendGetCells(ns, table_name, scan_spec); err != nil {
		return
	}
	return p.recvGetCells()
}

func (p *ClientServiceClient) sendGetCells(ns Namespace, table_name string, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_cells", thrift.CALL, p.SeqId)
	args224 := NewGetCellsArgs()
	args224.Ns = ns
	args224.TableName = table_name
	args224.ScanSpec = scan_spec
	err = args224.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetCells() (value []*Cell, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error226 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error227 error
		error227, err = error226.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error227
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result225 := NewGetCellsResult()
	err = result225.Read(iprot)
	iprot.ReadMessageEnd()
	value = result225.Success
	if result225.E != nil {
		e = result225.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Ns
//  - Name
//  - ScanSpec
func (p *ClientServiceClient) GetCellsAsArrays(ns Namespace, name string, scan_spec *ScanSpec) (r []CellAsArray, e *ClientException, err error) {
	if err = p.sendGetCellsAsArrays(ns, name, scan_spec); err != nil {
		return
	}
	return p.recvGetCellsAsArrays()
}

func (p *ClientServiceClient) sendGetCellsAsArrays(ns Namespace, name string, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_cells_as_arrays", thrift.CALL, p.SeqId)
	args228 := NewGetCellsAsArraysArgs()
	args228.Ns = ns
	args228.Name = name
	args228.ScanSpec = scan_spec
	err = args228.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetCellsAsArrays() (value []CellAsArray, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error230 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error231 error
		error231, err = error230.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error231
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result229 := NewGetCellsAsArraysResult()
	err = result229.Read(iprot)
	iprot.ReadMessageEnd()
	value = result229.Success
	if result229.E != nil {
		e = result229.E
	}
	return
}

// Alternative interface returning buffer of serialized cells
//
// Parameters:
//  - Ns
//  - Name
//  - ScanSpec
func (p *ClientServiceClient) GetCellsSerialized(ns Namespace, name string, scan_spec *ScanSpec) (r CellsSerialized, e *ClientException, err error) {
	if err = p.sendGetCellsSerialized(ns, name, scan_spec); err != nil {
		return
	}
	return p.recvGetCellsSerialized()
}

func (p *ClientServiceClient) sendGetCellsSerialized(ns Namespace, name string, scan_spec *ScanSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_cells_serialized", thrift.CALL, p.SeqId)
	args232 := NewGetCellsSerializedArgs()
	args232.Ns = ns
	args232.Name = name
	args232.ScanSpec = scan_spec
	err = args232.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetCellsSerialized() (value CellsSerialized, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error234 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error235 error
		error235, err = error234.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error235
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result233 := NewGetCellsSerializedResult()
	err = result233.Read(iprot)
	iprot.ReadMessageEnd()
	value = result233.Success
	if result233.E != nil {
		e = result233.E
	}
	return
}

// Create a shared mutator with specified MutateSpec.
// Delete and recreate it if the mutator exists.
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param mutate_spec - mutator specification
//
//
// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
func (p *ClientServiceClient) SharedMutatorRefresh(ns Namespace, table_name string, mutate_spec *MutateSpec) (e *ClientException, err error) {
	if err = p.sendSharedMutatorRefresh(ns, table_name, mutate_spec); err != nil {
		return
	}
	return p.recvSharedMutatorRefresh()
}

func (p *ClientServiceClient) sendSharedMutatorRefresh(ns Namespace, table_name string, mutate_spec *MutateSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("shared_mutator_refresh", thrift.CALL, p.SeqId)
	args236 := NewSharedMutatorRefreshArgs()
	args236.Ns = ns
	args236.TableName = table_name
	args236.MutateSpec = mutate_spec
	err = args236.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSharedMutatorRefresh() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error238 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error239 error
		error239, err = error238.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error239
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result237 := NewSharedMutatorRefreshResult()
	err = result237.Read(iprot)
	iprot.ReadMessageEnd()
	if result237.E != nil {
		e = result237.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
func (p *ClientServiceClient) RefreshSharedMutator(ns Namespace, table_name string, mutate_spec *MutateSpec) (e *ClientException, err error) {
	if err = p.sendRefreshSharedMutator(ns, table_name, mutate_spec); err != nil {
		return
	}
	return p.recvRefreshSharedMutator()
}

func (p *ClientServiceClient) sendRefreshSharedMutator(ns Namespace, table_name string, mutate_spec *MutateSpec) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("refresh_shared_mutator", thrift.CALL, p.SeqId)
	args240 := NewRefreshSharedMutatorArgs()
	args240.Ns = ns
	args240.TableName = table_name
	args240.MutateSpec = mutate_spec
	err = args240.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvRefreshSharedMutator() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error242 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error243 error
		error243, err = error242.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error243
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result241 := NewRefreshSharedMutatorResult()
	err = result241.Read(iprot)
	iprot.ReadMessageEnd()
	if result241.E != nil {
		e = result241.E
	}
	return
}

// Open a shared periodic mutator which causes cells to be written asyncronously.
// Users beware: calling this method merely writes
// cells to a local buffer and does not guarantee that the cells have been persisted.
// If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param mutate_spec - mutator specification
//
// @param cells - set of cells to be written
//
// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cells
func (p *ClientServiceClient) SharedMutatorSetCells(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []*Cell) (e *ClientException, err error) {
	if err = p.sendSharedMutatorSetCells(ns, table_name, mutate_spec, cells); err != nil {
		return
	}
	return p.recvSharedMutatorSetCells()
}

func (p *ClientServiceClient) sendSharedMutatorSetCells(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []*Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("shared_mutator_set_cells", thrift.CALL, p.SeqId)
	args244 := NewSharedMutatorSetCellsArgs()
	args244.Ns = ns
	args244.TableName = table_name
	args244.MutateSpec = mutate_spec
	args244.Cells = cells
	err = args244.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSharedMutatorSetCells() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error246 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error247 error
		error247, err = error246.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error247
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result245 := NewSharedMutatorSetCellsResult()
	err = result245.Read(iprot)
	iprot.ReadMessageEnd()
	if result245.E != nil {
		e = result245.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cells
func (p *ClientServiceClient) OfferCells(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []*Cell) (e *ClientException, err error) {
	if err = p.sendOfferCells(ns, table_name, mutate_spec, cells); err != nil {
		return
	}
	return p.recvOfferCells()
}

func (p *ClientServiceClient) sendOfferCells(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []*Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("offer_cells", thrift.CALL, p.SeqId)
	args248 := NewOfferCellsArgs()
	args248.Ns = ns
	args248.TableName = table_name
	args248.MutateSpec = mutate_spec
	args248.Cells = cells
	err = args248.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOfferCells() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error250 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error251 error
		error251, err = error250.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error251
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result249 := NewOfferCellsResult()
	err = result249.Read(iprot)
	iprot.ReadMessageEnd()
	if result249.E != nil {
		e = result249.E
	}
	return
}

// Alternative to offer_cell interface using array as cell
//
// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cells
func (p *ClientServiceClient) SharedMutatorSetCellsAsArrays(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []CellAsArray) (e *ClientException, err error) {
	if err = p.sendSharedMutatorSetCellsAsArrays(ns, table_name, mutate_spec, cells); err != nil {
		return
	}
	return p.recvSharedMutatorSetCellsAsArrays()
}

func (p *ClientServiceClient) sendSharedMutatorSetCellsAsArrays(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("shared_mutator_set_cells_as_arrays", thrift.CALL, p.SeqId)
	args252 := NewSharedMutatorSetCellsAsArraysArgs()
	args252.Ns = ns
	args252.TableName = table_name
	args252.MutateSpec = mutate_spec
	args252.Cells = cells
	err = args252.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSharedMutatorSetCellsAsArrays() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error254 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error255 error
		error255, err = error254.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error255
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result253 := NewSharedMutatorSetCellsAsArraysResult()
	err = result253.Read(iprot)
	iprot.ReadMessageEnd()
	if result253.E != nil {
		e = result253.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cells
func (p *ClientServiceClient) OfferCellsAsArrays(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []CellAsArray) (e *ClientException, err error) {
	if err = p.sendOfferCellsAsArrays(ns, table_name, mutate_spec, cells); err != nil {
		return
	}
	return p.recvOfferCellsAsArrays()
}

func (p *ClientServiceClient) sendOfferCellsAsArrays(ns Namespace, table_name string, mutate_spec *MutateSpec, cells []CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("offer_cells_as_arrays", thrift.CALL, p.SeqId)
	args256 := NewOfferCellsAsArraysArgs()
	args256.Ns = ns
	args256.TableName = table_name
	args256.MutateSpec = mutate_spec
	args256.Cells = cells
	err = args256.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOfferCellsAsArrays() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error258 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error259 error
		error259, err = error258.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error259
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result257 := NewOfferCellsAsArraysResult()
	err = result257.Read(iprot)
	iprot.ReadMessageEnd()
	if result257.E != nil {
		e = result257.E
	}
	return
}

// Open a shared periodic mutator which causes cells to be written asyncronously.
// Users beware: calling this method merely writes
// cells to a local buffer and does not guarantee that the cells have been persisted.
// If you want guaranteed durability, use the open_mutator+set_cells* interface instead.
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param mutate_spec - mutator specification
//
// @param cell - cell to be written
//
// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cell
func (p *ClientServiceClient) SharedMutatorSetCell(ns Namespace, table_name string, mutate_spec *MutateSpec, cell *Cell) (e *ClientException, err error) {
	if err = p.sendSharedMutatorSetCell(ns, table_name, mutate_spec, cell); err != nil {
		return
	}
	return p.recvSharedMutatorSetCell()
}

func (p *ClientServiceClient) sendSharedMutatorSetCell(ns Namespace, table_name string, mutate_spec *MutateSpec, cell *Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("shared_mutator_set_cell", thrift.CALL, p.SeqId)
	args260 := NewSharedMutatorSetCellArgs()
	args260.Ns = ns
	args260.TableName = table_name
	args260.MutateSpec = mutate_spec
	args260.Cell = cell
	err = args260.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSharedMutatorSetCell() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error262 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error263 error
		error263, err = error262.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error263
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result261 := NewSharedMutatorSetCellResult()
	err = result261.Read(iprot)
	iprot.ReadMessageEnd()
	if result261.E != nil {
		e = result261.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cell
func (p *ClientServiceClient) OfferCell(ns Namespace, table_name string, mutate_spec *MutateSpec, cell *Cell) (e *ClientException, err error) {
	if err = p.sendOfferCell(ns, table_name, mutate_spec, cell); err != nil {
		return
	}
	return p.recvOfferCell()
}

func (p *ClientServiceClient) sendOfferCell(ns Namespace, table_name string, mutate_spec *MutateSpec, cell *Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("offer_cell", thrift.CALL, p.SeqId)
	args264 := NewOfferCellArgs()
	args264.Ns = ns
	args264.TableName = table_name
	args264.MutateSpec = mutate_spec
	args264.Cell = cell
	err = args264.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOfferCell() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error266 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error267 error
		error267, err = error266.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error267
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result265 := NewOfferCellResult()
	err = result265.Read(iprot)
	iprot.ReadMessageEnd()
	if result265.E != nil {
		e = result265.E
	}
	return
}

// Alternative to offer_cell interface using array as cell
//
// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cell
func (p *ClientServiceClient) SharedMutatorSetCellAsArray(ns Namespace, table_name string, mutate_spec *MutateSpec, cell CellAsArray) (e *ClientException, err error) {
	if err = p.sendSharedMutatorSetCellAsArray(ns, table_name, mutate_spec, cell); err != nil {
		return
	}
	return p.recvSharedMutatorSetCellAsArray()
}

func (p *ClientServiceClient) sendSharedMutatorSetCellAsArray(ns Namespace, table_name string, mutate_spec *MutateSpec, cell CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("shared_mutator_set_cell_as_array", thrift.CALL, p.SeqId)
	args268 := NewSharedMutatorSetCellAsArrayArgs()
	args268.Ns = ns
	args268.TableName = table_name
	args268.MutateSpec = mutate_spec
	args268.Cell = cell
	err = args268.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSharedMutatorSetCellAsArray() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error270 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error271 error
		error271, err = error270.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error271
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result269 := NewSharedMutatorSetCellAsArrayResult()
	err = result269.Read(iprot)
	iprot.ReadMessageEnd()
	if result269.E != nil {
		e = result269.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - MutateSpec
//  - Cell
func (p *ClientServiceClient) OfferCellAsArray(ns Namespace, table_name string, mutate_spec *MutateSpec, cell CellAsArray) (e *ClientException, err error) {
	if err = p.sendOfferCellAsArray(ns, table_name, mutate_spec, cell); err != nil {
		return
	}
	return p.recvOfferCellAsArray()
}

func (p *ClientServiceClient) sendOfferCellAsArray(ns Namespace, table_name string, mutate_spec *MutateSpec, cell CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("offer_cell_as_array", thrift.CALL, p.SeqId)
	args272 := NewOfferCellAsArrayArgs()
	args272.Ns = ns
	args272.TableName = table_name
	args272.MutateSpec = mutate_spec
	args272.Cell = cell
	err = args272.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOfferCellAsArray() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error274 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error275 error
		error275, err = error274.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error275
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result273 := NewOfferCellAsArrayResult()
	err = result273.Read(iprot)
	iprot.ReadMessageEnd()
	if result273.E != nil {
		e = result273.E
	}
	return
}

// Open a table mutator
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param flags - mutator flags
//
// @param flush_interval - auto-flush interval in milliseconds; 0 disables it.
//
// @return mutator id
//
// Parameters:
//  - Ns
//  - TableName
//  - Flags
//  - FlushInterval
func (p *ClientServiceClient) MutatorOpen(ns Namespace, table_name string, flags int32, flush_interval int32) (r Mutator, e *ClientException, err error) {
	if err = p.sendMutatorOpen(ns, table_name, flags, flush_interval); err != nil {
		return
	}
	return p.recvMutatorOpen()
}

func (p *ClientServiceClient) sendMutatorOpen(ns Namespace, table_name string, flags int32, flush_interval int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_open", thrift.CALL, p.SeqId)
	args276 := NewMutatorOpenArgs()
	args276.Ns = ns
	args276.TableName = table_name
	args276.Flags = flags
	args276.FlushInterval = flush_interval
	err = args276.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorOpen() (value Mutator, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error278 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error279 error
		error279, err = error278.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error279
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result277 := NewMutatorOpenResult()
	err = result277.Read(iprot)
	iprot.ReadMessageEnd()
	value = result277.Success
	if result277.E != nil {
		e = result277.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - Flags
//  - FlushInterval
func (p *ClientServiceClient) OpenMutator(ns Namespace, table_name string, flags int32, flush_interval int32) (r Mutator, e *ClientException, err error) {
	if err = p.sendOpenMutator(ns, table_name, flags, flush_interval); err != nil {
		return
	}
	return p.recvOpenMutator()
}

func (p *ClientServiceClient) sendOpenMutator(ns Namespace, table_name string, flags int32, flush_interval int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("open_mutator", thrift.CALL, p.SeqId)
	args280 := NewOpenMutatorArgs()
	args280.Ns = ns
	args280.TableName = table_name
	args280.Flags = flags
	args280.FlushInterval = flush_interval
	err = args280.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOpenMutator() (value Mutator, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error282 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error283 error
		error283, err = error282.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error283
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result281 := NewOpenMutatorResult()
	err = result281.Read(iprot)
	iprot.ReadMessageEnd()
	value = result281.Success
	if result281.E != nil {
		e = result281.E
	}
	return
}

// Open an asynchronous table mutator
//
// @param ns - namespace id
// @param table_name - table name
// @param future - callback object
// @param flags - mutator flags
//
// @return mutator id
//
// Parameters:
//  - Ns
//  - TableName
//  - Future
//  - Flags
func (p *ClientServiceClient) AsyncMutatorOpen(ns Namespace, table_name string, future Future, flags int32) (r MutatorAsync, e *ClientException, err error) {
	if err = p.sendAsyncMutatorOpen(ns, table_name, future, flags); err != nil {
		return
	}
	return p.recvAsyncMutatorOpen()
}

func (p *ClientServiceClient) sendAsyncMutatorOpen(ns Namespace, table_name string, future Future, flags int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_open", thrift.CALL, p.SeqId)
	args284 := NewAsyncMutatorOpenArgs()
	args284.Ns = ns
	args284.TableName = table_name
	args284.Future = future
	args284.Flags = flags
	err = args284.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorOpen() (value MutatorAsync, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error286 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error287 error
		error287, err = error286.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error287
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result285 := NewAsyncMutatorOpenResult()
	err = result285.Read(iprot)
	iprot.ReadMessageEnd()
	value = result285.Success
	if result285.E != nil {
		e = result285.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
//  - Future
//  - Flags
func (p *ClientServiceClient) OpenMutatorAsync(ns Namespace, table_name string, future Future, flags int32) (r MutatorAsync, e *ClientException, err error) {
	if err = p.sendOpenMutatorAsync(ns, table_name, future, flags); err != nil {
		return
	}
	return p.recvOpenMutatorAsync()
}

func (p *ClientServiceClient) sendOpenMutatorAsync(ns Namespace, table_name string, future Future, flags int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("open_mutator_async", thrift.CALL, p.SeqId)
	args288 := NewOpenMutatorAsyncArgs()
	args288.Ns = ns
	args288.TableName = table_name
	args288.Future = future
	args288.Flags = flags
	err = args288.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvOpenMutatorAsync() (value MutatorAsync, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error290 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error291 error
		error291, err = error290.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error291
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result289 := NewOpenMutatorAsyncResult()
	err = result289.Read(iprot)
	iprot.ReadMessageEnd()
	value = result289.Success
	if result289.E != nil {
		e = result289.E
	}
	return
}

// Close a table mutator
//
// @param mutator - mutator id to close
//
// Parameters:
//  - Mutator
func (p *ClientServiceClient) MutatorClose(mutator Mutator) (e *ClientException, err error) {
	if err = p.sendMutatorClose(mutator); err != nil {
		return
	}
	return p.recvMutatorClose()
}

func (p *ClientServiceClient) sendMutatorClose(mutator Mutator) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_close", thrift.CALL, p.SeqId)
	args292 := NewMutatorCloseArgs()
	args292.Mutator = mutator
	err = args292.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorClose() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error294 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error295 error
		error295, err = error294.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error295
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result293 := NewMutatorCloseResult()
	err = result293.Read(iprot)
	iprot.ReadMessageEnd()
	if result293.E != nil {
		e = result293.E
	}
	return
}

// Parameters:
//  - Mutator
func (p *ClientServiceClient) CloseMutator(mutator Mutator) (e *ClientException, err error) {
	if err = p.sendCloseMutator(mutator); err != nil {
		return
	}
	return p.recvCloseMutator()
}

func (p *ClientServiceClient) sendCloseMutator(mutator Mutator) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("close_mutator", thrift.CALL, p.SeqId)
	args296 := NewCloseMutatorArgs()
	args296.Mutator = mutator
	err = args296.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCloseMutator() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error298 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error299 error
		error299, err = error298.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error299
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result297 := NewCloseMutatorResult()
	err = result297.Read(iprot)
	iprot.ReadMessageEnd()
	if result297.E != nil {
		e = result297.E
	}
	return
}

// Cancel an asynchronous table mutator
//
// @param mutator -  mutator id to cancel
//
// Parameters:
//  - Mutator
func (p *ClientServiceClient) AsyncMutatorCancel(mutator MutatorAsync) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorCancel(mutator); err != nil {
		return
	}
	return p.recvAsyncMutatorCancel()
}

func (p *ClientServiceClient) sendAsyncMutatorCancel(mutator MutatorAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_cancel", thrift.CALL, p.SeqId)
	args300 := NewAsyncMutatorCancelArgs()
	args300.Mutator = mutator
	err = args300.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorCancel() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error302 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error303 error
		error303, err = error302.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error303
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result301 := NewAsyncMutatorCancelResult()
	err = result301.Read(iprot)
	iprot.ReadMessageEnd()
	if result301.E != nil {
		e = result301.E
	}
	return
}

// Parameters:
//  - Mutator
func (p *ClientServiceClient) CancelMutatorAsync(mutator MutatorAsync) (e *ClientException, err error) {
	if err = p.sendCancelMutatorAsync(mutator); err != nil {
		return
	}
	return p.recvCancelMutatorAsync()
}

func (p *ClientServiceClient) sendCancelMutatorAsync(mutator MutatorAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("cancel_mutator_async", thrift.CALL, p.SeqId)
	args304 := NewCancelMutatorAsyncArgs()
	args304.Mutator = mutator
	err = args304.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCancelMutatorAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error306 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error307 error
		error307, err = error306.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error307
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result305 := NewCancelMutatorAsyncResult()
	err = result305.Read(iprot)
	iprot.ReadMessageEnd()
	if result305.E != nil {
		e = result305.E
	}
	return
}

// Close an asynchronous table mutator
//
// @param mutator - mutator id to close
//
// Parameters:
//  - Mutator
func (p *ClientServiceClient) AsyncMutatorClose(mutator MutatorAsync) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorClose(mutator); err != nil {
		return
	}
	return p.recvAsyncMutatorClose()
}

func (p *ClientServiceClient) sendAsyncMutatorClose(mutator MutatorAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_close", thrift.CALL, p.SeqId)
	args308 := NewAsyncMutatorCloseArgs()
	args308.Mutator = mutator
	err = args308.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorClose() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error310 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error311 error
		error311, err = error310.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error311
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result309 := NewAsyncMutatorCloseResult()
	err = result309.Read(iprot)
	iprot.ReadMessageEnd()
	if result309.E != nil {
		e = result309.E
	}
	return
}

// Parameters:
//  - Mutator
func (p *ClientServiceClient) CloseMutatorAsync(mutator MutatorAsync) (e *ClientException, err error) {
	if err = p.sendCloseMutatorAsync(mutator); err != nil {
		return
	}
	return p.recvCloseMutatorAsync()
}

func (p *ClientServiceClient) sendCloseMutatorAsync(mutator MutatorAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("close_mutator_async", thrift.CALL, p.SeqId)
	args312 := NewCloseMutatorAsyncArgs()
	args312.Mutator = mutator
	err = args312.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCloseMutatorAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error314 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error315 error
		error315, err = error314.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error315
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result313 := NewCloseMutatorAsyncResult()
	err = result313.Read(iprot)
	iprot.ReadMessageEnd()
	if result313.E != nil {
		e = result313.E
	}
	return
}

// Set a cell via mutator
//
// @param mutator - mutator id
//
// @param cell - the cell to set
//
// Parameters:
//  - Mutator
//  - Cell
func (p *ClientServiceClient) MutatorSetCell(mutator Mutator, cell *Cell) (e *ClientException, err error) {
	if err = p.sendMutatorSetCell(mutator, cell); err != nil {
		return
	}
	return p.recvMutatorSetCell()
}

func (p *ClientServiceClient) sendMutatorSetCell(mutator Mutator, cell *Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_set_cell", thrift.CALL, p.SeqId)
	args316 := NewMutatorSetCellArgs()
	args316.Mutator = mutator
	args316.Cell = cell
	err = args316.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorSetCell() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error318 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error319 error
		error319, err = error318.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error319
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result317 := NewMutatorSetCellResult()
	err = result317.Read(iprot)
	iprot.ReadMessageEnd()
	if result317.E != nil {
		e = result317.E
	}
	return
}

// Set a cell in the table
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param cell - the cell to set
//
// Parameters:
//  - Ns
//  - TableName
//  - Cell
func (p *ClientServiceClient) SetCell(ns Namespace, table_name string, cell *Cell) (e *ClientException, err error) {
	if err = p.sendSetCell(ns, table_name, cell); err != nil {
		return
	}
	return p.recvSetCell()
}

func (p *ClientServiceClient) sendSetCell(ns Namespace, table_name string, cell *Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cell", thrift.CALL, p.SeqId)
	args320 := NewSetCellArgs()
	args320.Ns = ns
	args320.TableName = table_name
	args320.Cell = cell
	err = args320.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCell() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error322 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error323 error
		error323, err = error322.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error323
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result321 := NewSetCellResult()
	err = result321.Read(iprot)
	iprot.ReadMessageEnd()
	if result321.E != nil {
		e = result321.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Mutator
//  - Cell
func (p *ClientServiceClient) MutatorSetCellAsArray(mutator Mutator, cell CellAsArray) (e *ClientException, err error) {
	if err = p.sendMutatorSetCellAsArray(mutator, cell); err != nil {
		return
	}
	return p.recvMutatorSetCellAsArray()
}

func (p *ClientServiceClient) sendMutatorSetCellAsArray(mutator Mutator, cell CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_set_cell_as_array", thrift.CALL, p.SeqId)
	args324 := NewMutatorSetCellAsArrayArgs()
	args324.Mutator = mutator
	args324.Cell = cell
	err = args324.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorSetCellAsArray() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error326 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error327 error
		error327, err = error326.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error327
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result325 := NewMutatorSetCellAsArrayResult()
	err = result325.Read(iprot)
	iprot.ReadMessageEnd()
	if result325.E != nil {
		e = result325.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Ns
//  - TableName
//  - Cell
func (p *ClientServiceClient) SetCellAsArray(ns Namespace, table_name string, cell CellAsArray) (e *ClientException, err error) {
	if err = p.sendSetCellAsArray(ns, table_name, cell); err != nil {
		return
	}
	return p.recvSetCellAsArray()
}

func (p *ClientServiceClient) sendSetCellAsArray(ns Namespace, table_name string, cell CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cell_as_array", thrift.CALL, p.SeqId)
	args328 := NewSetCellAsArrayArgs()
	args328.Ns = ns
	args328.TableName = table_name
	args328.Cell = cell
	err = args328.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellAsArray() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error330 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error331 error
		error331, err = error330.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error331
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result329 := NewSetCellAsArrayResult()
	err = result329.Read(iprot)
	iprot.ReadMessageEnd()
	if result329.E != nil {
		e = result329.E
	}
	return
}

// Put a list of cells into a table via mutator
//
// @param mutator - mutator id
//
// @param cells - a list of cells (a cell with no row key set is assumed
//        to have the same row key as the previous cell)
//
// Parameters:
//  - Mutator
//  - Cells
func (p *ClientServiceClient) MutatorSetCells(mutator Mutator, cells []*Cell) (e *ClientException, err error) {
	if err = p.sendMutatorSetCells(mutator, cells); err != nil {
		return
	}
	return p.recvMutatorSetCells()
}

func (p *ClientServiceClient) sendMutatorSetCells(mutator Mutator, cells []*Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_set_cells", thrift.CALL, p.SeqId)
	args332 := NewMutatorSetCellsArgs()
	args332.Mutator = mutator
	args332.Cells = cells
	err = args332.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorSetCells() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error334 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error335 error
		error335, err = error334.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error335
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result333 := NewMutatorSetCellsResult()
	err = result333.Read(iprot)
	iprot.ReadMessageEnd()
	if result333.E != nil {
		e = result333.E
	}
	return
}

// Put a list of cells into a table
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @param cells - a list of cells (a cell with no row key set is assumed
//        to have the same row key as the previous cell)
//
// Parameters:
//  - Ns
//  - TableName
//  - Cells
func (p *ClientServiceClient) SetCells(ns Namespace, table_name string, cells []*Cell) (e *ClientException, err error) {
	if err = p.sendSetCells(ns, table_name, cells); err != nil {
		return
	}
	return p.recvSetCells()
}

func (p *ClientServiceClient) sendSetCells(ns Namespace, table_name string, cells []*Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cells", thrift.CALL, p.SeqId)
	args336 := NewSetCellsArgs()
	args336.Ns = ns
	args336.TableName = table_name
	args336.Cells = cells
	err = args336.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCells() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error338 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error339 error
		error339, err = error338.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error339
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result337 := NewSetCellsResult()
	err = result337.Read(iprot)
	iprot.ReadMessageEnd()
	if result337.E != nil {
		e = result337.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Mutator
//  - Cells
func (p *ClientServiceClient) MutatorSetCellsAsArrays(mutator Mutator, cells []CellAsArray) (e *ClientException, err error) {
	if err = p.sendMutatorSetCellsAsArrays(mutator, cells); err != nil {
		return
	}
	return p.recvMutatorSetCellsAsArrays()
}

func (p *ClientServiceClient) sendMutatorSetCellsAsArrays(mutator Mutator, cells []CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_set_cells_as_arrays", thrift.CALL, p.SeqId)
	args340 := NewMutatorSetCellsAsArraysArgs()
	args340.Mutator = mutator
	args340.Cells = cells
	err = args340.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorSetCellsAsArrays() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error342 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error343 error
		error343, err = error342.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error343
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result341 := NewMutatorSetCellsAsArraysResult()
	err = result341.Read(iprot)
	iprot.ReadMessageEnd()
	if result341.E != nil {
		e = result341.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Ns
//  - TableName
//  - Cells
func (p *ClientServiceClient) SetCellsAsArrays(ns Namespace, table_name string, cells []CellAsArray) (e *ClientException, err error) {
	if err = p.sendSetCellsAsArrays(ns, table_name, cells); err != nil {
		return
	}
	return p.recvSetCellsAsArrays()
}

func (p *ClientServiceClient) sendSetCellsAsArrays(ns Namespace, table_name string, cells []CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cells_as_arrays", thrift.CALL, p.SeqId)
	args344 := NewSetCellsAsArraysArgs()
	args344.Ns = ns
	args344.TableName = table_name
	args344.Cells = cells
	err = args344.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellsAsArrays() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error346 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error347 error
		error347, err = error346.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error347
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result345 := NewSetCellsAsArraysResult()
	err = result345.Read(iprot)
	iprot.ReadMessageEnd()
	if result345.E != nil {
		e = result345.E
	}
	return
}

// Alternative interface using buffer of serialized cells
//
// Parameters:
//  - Mutator
//  - Cells
//  - Flush
func (p *ClientServiceClient) MutatorSetCellsSerialized(mutator Mutator, cells CellsSerialized, flush bool) (e *ClientException, err error) {
	if err = p.sendMutatorSetCellsSerialized(mutator, cells, flush); err != nil {
		return
	}
	return p.recvMutatorSetCellsSerialized()
}

func (p *ClientServiceClient) sendMutatorSetCellsSerialized(mutator Mutator, cells CellsSerialized, flush bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_set_cells_serialized", thrift.CALL, p.SeqId)
	args348 := NewMutatorSetCellsSerializedArgs()
	args348.Mutator = mutator
	args348.Cells = cells
	args348.Flush = flush
	err = args348.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorSetCellsSerialized() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error350 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error351 error
		error351, err = error350.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error351
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result349 := NewMutatorSetCellsSerializedResult()
	err = result349.Read(iprot)
	iprot.ReadMessageEnd()
	if result349.E != nil {
		e = result349.E
	}
	return
}

// Alternative interface using buffer of serialized cells
//
// Parameters:
//  - Ns
//  - TableName
//  - Cells
func (p *ClientServiceClient) SetCellsSerialized(ns Namespace, table_name string, cells CellsSerialized) (e *ClientException, err error) {
	if err = p.sendSetCellsSerialized(ns, table_name, cells); err != nil {
		return
	}
	return p.recvSetCellsSerialized()
}

func (p *ClientServiceClient) sendSetCellsSerialized(ns Namespace, table_name string, cells CellsSerialized) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cells_serialized", thrift.CALL, p.SeqId)
	args352 := NewSetCellsSerializedArgs()
	args352.Ns = ns
	args352.TableName = table_name
	args352.Cells = cells
	err = args352.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellsSerialized() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error354 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error355 error
		error355, err = error354.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error355
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result353 := NewSetCellsSerializedResult()
	err = result353.Read(iprot)
	iprot.ReadMessageEnd()
	if result353.E != nil {
		e = result353.E
	}
	return
}

// Flush mutator buffers
//
// Parameters:
//  - Mutator
func (p *ClientServiceClient) MutatorFlush(mutator Mutator) (e *ClientException, err error) {
	if err = p.sendMutatorFlush(mutator); err != nil {
		return
	}
	return p.recvMutatorFlush()
}

func (p *ClientServiceClient) sendMutatorFlush(mutator Mutator) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("mutator_flush", thrift.CALL, p.SeqId)
	args356 := NewMutatorFlushArgs()
	args356.Mutator = mutator
	err = args356.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvMutatorFlush() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error358 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error359 error
		error359, err = error358.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error359
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result357 := NewMutatorFlushResult()
	err = result357.Read(iprot)
	iprot.ReadMessageEnd()
	if result357.E != nil {
		e = result357.E
	}
	return
}

// Parameters:
//  - Mutator
func (p *ClientServiceClient) FlushMutator(mutator Mutator) (e *ClientException, err error) {
	if err = p.sendFlushMutator(mutator); err != nil {
		return
	}
	return p.recvFlushMutator()
}

func (p *ClientServiceClient) sendFlushMutator(mutator Mutator) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("flush_mutator", thrift.CALL, p.SeqId)
	args360 := NewFlushMutatorArgs()
	args360.Mutator = mutator
	err = args360.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFlushMutator() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error362 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error363 error
		error363, err = error362.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error363
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result361 := NewFlushMutatorResult()
	err = result361.Read(iprot)
	iprot.ReadMessageEnd()
	if result361.E != nil {
		e = result361.E
	}
	return
}

// Set a cell in the table using an asynchonous mutator
//
// @param mutator - mutator id
//
// @param cell - the cell to set
//
// Parameters:
//  - Mutator
//  - Cell
func (p *ClientServiceClient) AsyncMutatorSetCell(mutator MutatorAsync, cell *Cell) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorSetCell(mutator, cell); err != nil {
		return
	}
	return p.recvAsyncMutatorSetCell()
}

func (p *ClientServiceClient) sendAsyncMutatorSetCell(mutator MutatorAsync, cell *Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_set_cell", thrift.CALL, p.SeqId)
	args364 := NewAsyncMutatorSetCellArgs()
	args364.Mutator = mutator
	args364.Cell = cell
	err = args364.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorSetCell() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error366 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error367 error
		error367, err = error366.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error367
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result365 := NewAsyncMutatorSetCellResult()
	err = result365.Read(iprot)
	iprot.ReadMessageEnd()
	if result365.E != nil {
		e = result365.E
	}
	return
}

// Parameters:
//  - Mutator
//  - Cell
func (p *ClientServiceClient) SetCellAsync(mutator MutatorAsync, cell *Cell) (e *ClientException, err error) {
	if err = p.sendSetCellAsync(mutator, cell); err != nil {
		return
	}
	return p.recvSetCellAsync()
}

func (p *ClientServiceClient) sendSetCellAsync(mutator MutatorAsync, cell *Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cell_async", thrift.CALL, p.SeqId)
	args368 := NewSetCellAsyncArgs()
	args368.Mutator = mutator
	args368.Cell = cell
	err = args368.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error370 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error371 error
		error371, err = error370.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error371
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result369 := NewSetCellAsyncResult()
	err = result369.Read(iprot)
	iprot.ReadMessageEnd()
	if result369.E != nil {
		e = result369.E
	}
	return
}

// Alternative interface using array as cell using an asynchonous mutator
//
// Parameters:
//  - Mutator
//  - Cell
func (p *ClientServiceClient) AsyncMutatorSetCellAsArray(mutator MutatorAsync, cell CellAsArray) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorSetCellAsArray(mutator, cell); err != nil {
		return
	}
	return p.recvAsyncMutatorSetCellAsArray()
}

func (p *ClientServiceClient) sendAsyncMutatorSetCellAsArray(mutator MutatorAsync, cell CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_set_cell_as_array", thrift.CALL, p.SeqId)
	args372 := NewAsyncMutatorSetCellAsArrayArgs()
	args372.Mutator = mutator
	args372.Cell = cell
	err = args372.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorSetCellAsArray() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error374 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error375 error
		error375, err = error374.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error375
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result373 := NewAsyncMutatorSetCellAsArrayResult()
	err = result373.Read(iprot)
	iprot.ReadMessageEnd()
	if result373.E != nil {
		e = result373.E
	}
	return
}

// Parameters:
//  - Mutator
//  - Cell
func (p *ClientServiceClient) SetCellAsArrayAsync(mutator MutatorAsync, cell CellAsArray) (e *ClientException, err error) {
	if err = p.sendSetCellAsArrayAsync(mutator, cell); err != nil {
		return
	}
	return p.recvSetCellAsArrayAsync()
}

func (p *ClientServiceClient) sendSetCellAsArrayAsync(mutator MutatorAsync, cell CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cell_as_array_async", thrift.CALL, p.SeqId)
	args376 := NewSetCellAsArrayAsyncArgs()
	args376.Mutator = mutator
	args376.Cell = cell
	err = args376.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellAsArrayAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error378 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error379 error
		error379, err = error378.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error379
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result377 := NewSetCellAsArrayAsyncResult()
	err = result377.Read(iprot)
	iprot.ReadMessageEnd()
	if result377.E != nil {
		e = result377.E
	}
	return
}

// Put a list of cells into a table using asynchonous mutator
//
// @param mutator - mutator id
//
// @param cells - a list of cells (a cell with no row key set is assumed
//        to have the same row key as the previous cell)
//
// Parameters:
//  - Mutator
//  - Cells
func (p *ClientServiceClient) AsyncMutatorSetCells(mutator MutatorAsync, cells []*Cell) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorSetCells(mutator, cells); err != nil {
		return
	}
	return p.recvAsyncMutatorSetCells()
}

func (p *ClientServiceClient) sendAsyncMutatorSetCells(mutator MutatorAsync, cells []*Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_set_cells", thrift.CALL, p.SeqId)
	args380 := NewAsyncMutatorSetCellsArgs()
	args380.Mutator = mutator
	args380.Cells = cells
	err = args380.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorSetCells() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error382 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error383 error
		error383, err = error382.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error383
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result381 := NewAsyncMutatorSetCellsResult()
	err = result381.Read(iprot)
	iprot.ReadMessageEnd()
	if result381.E != nil {
		e = result381.E
	}
	return
}

// Parameters:
//  - Mutator
//  - Cells
func (p *ClientServiceClient) SetCellsAsync(mutator MutatorAsync, cells []*Cell) (e *ClientException, err error) {
	if err = p.sendSetCellsAsync(mutator, cells); err != nil {
		return
	}
	return p.recvSetCellsAsync()
}

func (p *ClientServiceClient) sendSetCellsAsync(mutator MutatorAsync, cells []*Cell) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cells_async", thrift.CALL, p.SeqId)
	args384 := NewSetCellsAsyncArgs()
	args384.Mutator = mutator
	args384.Cells = cells
	err = args384.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellsAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error386 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error387 error
		error387, err = error386.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error387
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result385 := NewSetCellsAsyncResult()
	err = result385.Read(iprot)
	iprot.ReadMessageEnd()
	if result385.E != nil {
		e = result385.E
	}
	return
}

// Alternative interface using array as cell
//
// Parameters:
//  - Mutator
//  - Cells
func (p *ClientServiceClient) AsyncMutatorSetCellsAsArrays(mutator MutatorAsync, cells []CellAsArray) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorSetCellsAsArrays(mutator, cells); err != nil {
		return
	}
	return p.recvAsyncMutatorSetCellsAsArrays()
}

func (p *ClientServiceClient) sendAsyncMutatorSetCellsAsArrays(mutator MutatorAsync, cells []CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_set_cells_as_arrays", thrift.CALL, p.SeqId)
	args388 := NewAsyncMutatorSetCellsAsArraysArgs()
	args388.Mutator = mutator
	args388.Cells = cells
	err = args388.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorSetCellsAsArrays() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error390 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error391 error
		error391, err = error390.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error391
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result389 := NewAsyncMutatorSetCellsAsArraysResult()
	err = result389.Read(iprot)
	iprot.ReadMessageEnd()
	if result389.E != nil {
		e = result389.E
	}
	return
}

// Parameters:
//  - Mutator
//  - Cells
func (p *ClientServiceClient) SetCellsAsArraysAsync(mutator MutatorAsync, cells []CellAsArray) (e *ClientException, err error) {
	if err = p.sendSetCellsAsArraysAsync(mutator, cells); err != nil {
		return
	}
	return p.recvSetCellsAsArraysAsync()
}

func (p *ClientServiceClient) sendSetCellsAsArraysAsync(mutator MutatorAsync, cells []CellAsArray) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cells_as_arrays_async", thrift.CALL, p.SeqId)
	args392 := NewSetCellsAsArraysAsyncArgs()
	args392.Mutator = mutator
	args392.Cells = cells
	err = args392.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellsAsArraysAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error394 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error395 error
		error395, err = error394.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error395
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result393 := NewSetCellsAsArraysAsyncResult()
	err = result393.Read(iprot)
	iprot.ReadMessageEnd()
	if result393.E != nil {
		e = result393.E
	}
	return
}

// Alternative interface using buffer of serialized cells
//
// Parameters:
//  - Mutator
//  - Cells
//  - Flush
func (p *ClientServiceClient) AsyncMutatorSetCellsSerialized(mutator MutatorAsync, cells CellsSerialized, flush bool) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorSetCellsSerialized(mutator, cells, flush); err != nil {
		return
	}
	return p.recvAsyncMutatorSetCellsSerialized()
}

func (p *ClientServiceClient) sendAsyncMutatorSetCellsSerialized(mutator MutatorAsync, cells CellsSerialized, flush bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_set_cells_serialized", thrift.CALL, p.SeqId)
	args396 := NewAsyncMutatorSetCellsSerializedArgs()
	args396.Mutator = mutator
	args396.Cells = cells
	args396.Flush = flush
	err = args396.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorSetCellsSerialized() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error398 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error399 error
		error399, err = error398.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error399
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result397 := NewAsyncMutatorSetCellsSerializedResult()
	err = result397.Read(iprot)
	iprot.ReadMessageEnd()
	if result397.E != nil {
		e = result397.E
	}
	return
}

// Parameters:
//  - Mutator
//  - Cells
//  - Flush
func (p *ClientServiceClient) SetCellsSerializedAsync(mutator MutatorAsync, cells CellsSerialized, flush bool) (e *ClientException, err error) {
	if err = p.sendSetCellsSerializedAsync(mutator, cells, flush); err != nil {
		return
	}
	return p.recvSetCellsSerializedAsync()
}

func (p *ClientServiceClient) sendSetCellsSerializedAsync(mutator MutatorAsync, cells CellsSerialized, flush bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cells_serialized_async", thrift.CALL, p.SeqId)
	args400 := NewSetCellsSerializedAsyncArgs()
	args400.Mutator = mutator
	args400.Cells = cells
	args400.Flush = flush
	err = args400.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvSetCellsSerializedAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error402 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error403 error
		error403, err = error402.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error403
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result401 := NewSetCellsSerializedAsyncResult()
	err = result401.Read(iprot)
	iprot.ReadMessageEnd()
	if result401.E != nil {
		e = result401.E
	}
	return
}

// Flush mutator buffers
//
// Parameters:
//  - Mutator
func (p *ClientServiceClient) AsyncMutatorFlush(mutator MutatorAsync) (e *ClientException, err error) {
	if err = p.sendAsyncMutatorFlush(mutator); err != nil {
		return
	}
	return p.recvAsyncMutatorFlush()
}

func (p *ClientServiceClient) sendAsyncMutatorFlush(mutator MutatorAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("async_mutator_flush", thrift.CALL, p.SeqId)
	args404 := NewAsyncMutatorFlushArgs()
	args404.Mutator = mutator
	err = args404.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvAsyncMutatorFlush() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error406 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error407 error
		error407, err = error406.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error407
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result405 := NewAsyncMutatorFlushResult()
	err = result405.Read(iprot)
	iprot.ReadMessageEnd()
	if result405.E != nil {
		e = result405.E
	}
	return
}

// Parameters:
//  - Mutator
func (p *ClientServiceClient) FlushMutatorAsync(mutator MutatorAsync) (e *ClientException, err error) {
	if err = p.sendFlushMutatorAsync(mutator); err != nil {
		return
	}
	return p.recvFlushMutatorAsync()
}

func (p *ClientServiceClient) sendFlushMutatorAsync(mutator MutatorAsync) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("flush_mutator_async", thrift.CALL, p.SeqId)
	args408 := NewFlushMutatorAsyncArgs()
	args408.Mutator = mutator
	err = args408.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvFlushMutatorAsync() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error410 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error411 error
		error411, err = error410.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error411
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result409 := NewFlushMutatorAsyncResult()
	err = result409.Read(iprot)
	iprot.ReadMessageEnd()
	if result409.E != nil {
		e = result409.E
	}
	return
}

// Check if the namespace exists
//
// @param ns - namespace name
//
// @return true if ns exists, false ow
//
// Parameters:
//  - Ns
func (p *ClientServiceClient) NamespaceExists(ns string) (r bool, e *ClientException, err error) {
	if err = p.sendNamespaceExists(ns); err != nil {
		return
	}
	return p.recvNamespaceExists()
}

func (p *ClientServiceClient) sendNamespaceExists(ns string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("namespace_exists", thrift.CALL, p.SeqId)
	args412 := NewNamespaceExistsArgs()
	args412.Ns = ns
	err = args412.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNamespaceExists() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error414 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error415 error
		error415, err = error414.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error415
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result413 := NewNamespaceExistsResult()
	err = result413.Read(iprot)
	iprot.ReadMessageEnd()
	value = result413.Success
	if result413.E != nil {
		e = result413.E
	}
	return
}

// Parameters:
//  - Ns
func (p *ClientServiceClient) ExistsNamespace(ns string) (r bool, e *ClientException, err error) {
	if err = p.sendExistsNamespace(ns); err != nil {
		return
	}
	return p.recvExistsNamespace()
}

func (p *ClientServiceClient) sendExistsNamespace(ns string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("exists_namespace", thrift.CALL, p.SeqId)
	args416 := NewExistsNamespaceArgs()
	args416.Ns = ns
	err = args416.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvExistsNamespace() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error418 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error419 error
		error419, err = error418.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error419
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result417 := NewExistsNamespaceResult()
	err = result417.Read(iprot)
	iprot.ReadMessageEnd()
	value = result417.Success
	if result417.E != nil {
		e = result417.E
	}
	return
}

// Check if the table exists
//
// @param ns - namespace id
//
// @param name - table name
//
// @return true if table exists, false ow
//
// Parameters:
//  - Ns
//  - Name
func (p *ClientServiceClient) ExistsTable(ns Namespace, name string) (r bool, e *ClientException, err error) {
	if err = p.sendExistsTable(ns, name); err != nil {
		return
	}
	return p.recvExistsTable()
}

func (p *ClientServiceClient) sendExistsTable(ns Namespace, name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("exists_table", thrift.CALL, p.SeqId)
	args420 := NewExistsTableArgs()
	args420.Ns = ns
	args420.Name = name
	err = args420.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvExistsTable() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error422 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error423 error
		error423, err = error422.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error423
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result421 := NewExistsTableResult()
	err = result421.Read(iprot)
	iprot.ReadMessageEnd()
	value = result421.Success
	if result421.E != nil {
		e = result421.E
	}
	return
}

// Parameters:
//  - Ns
//  - Name
func (p *ClientServiceClient) TableExists(ns Namespace, name string) (r bool, e *ClientException, err error) {
	if err = p.sendTableExists(ns, name); err != nil {
		return
	}
	return p.recvTableExists()
}

func (p *ClientServiceClient) sendTableExists(ns Namespace, name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_exists", thrift.CALL, p.SeqId)
	args424 := NewTableExistsArgs()
	args424.Ns = ns
	args424.Name = name
	err = args424.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableExists() (value bool, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error426 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error427 error
		error427, err = error426.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error427
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result425 := NewTableExistsResult()
	err = result425.Read(iprot)
	iprot.ReadMessageEnd()
	value = result425.Success
	if result425.E != nil {
		e = result425.E
	}
	return
}

// Get the id of a table
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @return table id string
//
// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) TableGetId(ns Namespace, table_name string) (r string, e *ClientException, err error) {
	if err = p.sendTableGetId(ns, table_name); err != nil {
		return
	}
	return p.recvTableGetId()
}

func (p *ClientServiceClient) sendTableGetId(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_get_id", thrift.CALL, p.SeqId)
	args428 := NewTableGetIdArgs()
	args428.Ns = ns
	args428.TableName = table_name
	err = args428.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableGetId() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error430 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error431 error
		error431, err = error430.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error431
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result429 := NewTableGetIdResult()
	err = result429.Read(iprot)
	iprot.ReadMessageEnd()
	value = result429.Success
	if result429.E != nil {
		e = result429.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) GetTableId(ns Namespace, table_name string) (r string, e *ClientException, err error) {
	if err = p.sendGetTableId(ns, table_name); err != nil {
		return
	}
	return p.recvGetTableId()
}

func (p *ClientServiceClient) sendGetTableId(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_table_id", thrift.CALL, p.SeqId)
	args432 := NewGetTableIdArgs()
	args432.Ns = ns
	args432.TableName = table_name
	err = args432.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetTableId() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error434 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error435 error
		error435, err = error434.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error435
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result433 := NewGetTableIdResult()
	err = result433.Read(iprot)
	iprot.ReadMessageEnd()
	value = result433.Success
	if result433.E != nil {
		e = result433.E
	}
	return
}

// Get the schema of a table as a string (that can be used with create_table)
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @return schema string (in xml)
//
// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) TableGetSchemaStr(ns Namespace, table_name string) (r string, e *ClientException, err error) {
	if err = p.sendTableGetSchemaStr(ns, table_name); err != nil {
		return
	}
	return p.recvTableGetSchemaStr()
}

func (p *ClientServiceClient) sendTableGetSchemaStr(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_get_schema_str", thrift.CALL, p.SeqId)
	args436 := NewTableGetSchemaStrArgs()
	args436.Ns = ns
	args436.TableName = table_name
	err = args436.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableGetSchemaStr() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error438 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error439 error
		error439, err = error438.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error439
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result437 := NewTableGetSchemaStrResult()
	err = result437.Read(iprot)
	iprot.ReadMessageEnd()
	value = result437.Success
	if result437.E != nil {
		e = result437.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) GetSchemaStr(ns Namespace, table_name string) (r string, e *ClientException, err error) {
	if err = p.sendGetSchemaStr(ns, table_name); err != nil {
		return
	}
	return p.recvGetSchemaStr()
}

func (p *ClientServiceClient) sendGetSchemaStr(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_schema_str", thrift.CALL, p.SeqId)
	args440 := NewGetSchemaStrArgs()
	args440.Ns = ns
	args440.TableName = table_name
	err = args440.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetSchemaStr() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error442 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error443 error
		error443, err = error442.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error443
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result441 := NewGetSchemaStrResult()
	err = result441.Read(iprot)
	iprot.ReadMessageEnd()
	value = result441.Success
	if result441.E != nil {
		e = result441.E
	}
	return
}

// Get the schema of a table as a string along with column family ids
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @return schema string (in xml)
//
// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) TableGetSchemaStrWithIds(ns Namespace, table_name string) (r string, e *ClientException, err error) {
	if err = p.sendTableGetSchemaStrWithIds(ns, table_name); err != nil {
		return
	}
	return p.recvTableGetSchemaStrWithIds()
}

func (p *ClientServiceClient) sendTableGetSchemaStrWithIds(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_get_schema_str_with_ids", thrift.CALL, p.SeqId)
	args444 := NewTableGetSchemaStrWithIdsArgs()
	args444.Ns = ns
	args444.TableName = table_name
	err = args444.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableGetSchemaStrWithIds() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error446 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error447 error
		error447, err = error446.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error447
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result445 := NewTableGetSchemaStrWithIdsResult()
	err = result445.Read(iprot)
	iprot.ReadMessageEnd()
	value = result445.Success
	if result445.E != nil {
		e = result445.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) GetSchemaStrWithIds(ns Namespace, table_name string) (r string, e *ClientException, err error) {
	if err = p.sendGetSchemaStrWithIds(ns, table_name); err != nil {
		return
	}
	return p.recvGetSchemaStrWithIds()
}

func (p *ClientServiceClient) sendGetSchemaStrWithIds(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_schema_str_with_ids", thrift.CALL, p.SeqId)
	args448 := NewGetSchemaStrWithIdsArgs()
	args448.Ns = ns
	args448.TableName = table_name
	err = args448.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetSchemaStrWithIds() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error450 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error451 error
		error451, err = error450.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error451
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result449 := NewGetSchemaStrWithIdsResult()
	err = result449.Read(iprot)
	iprot.ReadMessageEnd()
	value = result449.Success
	if result449.E != nil {
		e = result449.E
	}
	return
}

// Get the schema of a table as a string (that can be used with create_table)
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @return schema object describing a table
//
// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) TableGetSchema(ns Namespace, table_name string) (r *Schema, e *ClientException, err error) {
	if err = p.sendTableGetSchema(ns, table_name); err != nil {
		return
	}
	return p.recvTableGetSchema()
}

func (p *ClientServiceClient) sendTableGetSchema(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_get_schema", thrift.CALL, p.SeqId)
	args452 := NewTableGetSchemaArgs()
	args452.Ns = ns
	args452.TableName = table_name
	err = args452.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableGetSchema() (value *Schema, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error454 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error455 error
		error455, err = error454.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error455
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result453 := NewTableGetSchemaResult()
	err = result453.Read(iprot)
	iprot.ReadMessageEnd()
	value = result453.Success
	if result453.E != nil {
		e = result453.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) GetSchema(ns Namespace, table_name string) (r *Schema, e *ClientException, err error) {
	if err = p.sendGetSchema(ns, table_name); err != nil {
		return
	}
	return p.recvGetSchema()
}

func (p *ClientServiceClient) sendGetSchema(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_schema", thrift.CALL, p.SeqId)
	args456 := NewGetSchemaArgs()
	args456.Ns = ns
	args456.TableName = table_name
	err = args456.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetSchema() (value *Schema, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error458 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error459 error
		error459, err = error458.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error459
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result457 := NewGetSchemaResult()
	err = result457.Read(iprot)
	iprot.ReadMessageEnd()
	value = result457.Success
	if result457.E != nil {
		e = result457.E
	}
	return
}

// Get a list of table names in the namespace
//
// @param ns - namespace id
//
// @return a list of table names
//
// Parameters:
//  - Ns
func (p *ClientServiceClient) GetTables(ns Namespace) (r []string, e *ClientException, err error) {
	if err = p.sendGetTables(ns); err != nil {
		return
	}
	return p.recvGetTables()
}

func (p *ClientServiceClient) sendGetTables(ns Namespace) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_tables", thrift.CALL, p.SeqId)
	args460 := NewGetTablesArgs()
	args460.Ns = ns
	err = args460.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetTables() (value []string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error462 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error463 error
		error463, err = error462.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error463
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result461 := NewGetTablesResult()
	err = result461.Read(iprot)
	iprot.ReadMessageEnd()
	value = result461.Success
	if result461.E != nil {
		e = result461.E
	}
	return
}

// Get a list of namespaces and table names table names in the namespace
//
// @param ns - namespace
//
// @return a list of table names
//
// Parameters:
//  - Ns
func (p *ClientServiceClient) NamespaceGetListing(ns Namespace) (r []*NamespaceListing, e *ClientException, err error) {
	if err = p.sendNamespaceGetListing(ns); err != nil {
		return
	}
	return p.recvNamespaceGetListing()
}

func (p *ClientServiceClient) sendNamespaceGetListing(ns Namespace) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("namespace_get_listing", thrift.CALL, p.SeqId)
	args464 := NewNamespaceGetListingArgs()
	args464.Ns = ns
	err = args464.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNamespaceGetListing() (value []*NamespaceListing, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error466 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error467 error
		error467, err = error466.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error467
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result465 := NewNamespaceGetListingResult()
	err = result465.Read(iprot)
	iprot.ReadMessageEnd()
	value = result465.Success
	if result465.E != nil {
		e = result465.E
	}
	return
}

// Parameters:
//  - Ns
func (p *ClientServiceClient) GetListing(ns Namespace) (r []*NamespaceListing, e *ClientException, err error) {
	if err = p.sendGetListing(ns); err != nil {
		return
	}
	return p.recvGetListing()
}

func (p *ClientServiceClient) sendGetListing(ns Namespace) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_listing", thrift.CALL, p.SeqId)
	args468 := NewGetListingArgs()
	args468.Ns = ns
	err = args468.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetListing() (value []*NamespaceListing, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error470 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error471 error
		error471, err = error470.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error471
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result469 := NewGetListingResult()
	err = result469.Read(iprot)
	iprot.ReadMessageEnd()
	value = result469.Success
	if result469.E != nil {
		e = result469.E
	}
	return
}

// Get a list of table splits
//
// @param ns - namespace id
//
// @param table_name - table name
//
// @return a list of table names
//
// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) TableGetSplits(ns Namespace, table_name string) (r []*TableSplit, e *ClientException, err error) {
	if err = p.sendTableGetSplits(ns, table_name); err != nil {
		return
	}
	return p.recvTableGetSplits()
}

func (p *ClientServiceClient) sendTableGetSplits(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_get_splits", thrift.CALL, p.SeqId)
	args472 := NewTableGetSplitsArgs()
	args472.Ns = ns
	args472.TableName = table_name
	err = args472.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableGetSplits() (value []*TableSplit, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error474 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error475 error
		error475, err = error474.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error475
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result473 := NewTableGetSplitsResult()
	err = result473.Read(iprot)
	iprot.ReadMessageEnd()
	value = result473.Success
	if result473.E != nil {
		e = result473.E
	}
	return
}

// Parameters:
//  - Ns
//  - TableName
func (p *ClientServiceClient) GetTableSplits(ns Namespace, table_name string) (r []*TableSplit, e *ClientException, err error) {
	if err = p.sendGetTableSplits(ns, table_name); err != nil {
		return
	}
	return p.recvGetTableSplits()
}

func (p *ClientServiceClient) sendGetTableSplits(ns Namespace, table_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_table_splits", thrift.CALL, p.SeqId)
	args476 := NewGetTableSplitsArgs()
	args476.Ns = ns
	args476.TableName = table_name
	err = args476.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGetTableSplits() (value []*TableSplit, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error478 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error479 error
		error479, err = error478.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error479
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result477 := NewGetTableSplitsResult()
	err = result477.Read(iprot)
	iprot.ReadMessageEnd()
	value = result477.Success
	if result477.E != nil {
		e = result477.E
	}
	return
}

// Drop a namespace
//
// @param ns - namespace name
//
// @param if_exists - if true, don't barf if the table doesn't exist
//
// Parameters:
//  - Ns
//  - IfExists
func (p *ClientServiceClient) NamespaceDrop(ns string, if_exists bool) (e *ClientException, err error) {
	if err = p.sendNamespaceDrop(ns, if_exists); err != nil {
		return
	}
	return p.recvNamespaceDrop()
}

func (p *ClientServiceClient) sendNamespaceDrop(ns string, if_exists bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("namespace_drop", thrift.CALL, p.SeqId)
	args480 := NewNamespaceDropArgs()
	args480.Ns = ns
	args480.IfExists = if_exists
	err = args480.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvNamespaceDrop() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error482 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error483 error
		error483, err = error482.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error483
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result481 := NewNamespaceDropResult()
	err = result481.Read(iprot)
	iprot.ReadMessageEnd()
	if result481.E != nil {
		e = result481.E
	}
	return
}

// Parameters:
//  - Ns
//  - IfExists
func (p *ClientServiceClient) DropNamespace(ns string, if_exists bool) (e *ClientException, err error) {
	if err = p.sendDropNamespace(ns, if_exists); err != nil {
		return
	}
	return p.recvDropNamespace()
}

func (p *ClientServiceClient) sendDropNamespace(ns string, if_exists bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("drop_namespace", thrift.CALL, p.SeqId)
	args484 := NewDropNamespaceArgs()
	args484.Ns = ns
	args484.IfExists = if_exists
	err = args484.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvDropNamespace() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error486 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error487 error
		error487, err = error486.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error487
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result485 := NewDropNamespaceResult()
	err = result485.Read(iprot)
	iprot.ReadMessageEnd()
	if result485.E != nil {
		e = result485.E
	}
	return
}

// Rename a table
//
// @param ns - namespace id
//
// @param name - current table name
//
// @param new_name - new table name
//
// Parameters:
//  - Ns
//  - Name
//  - NewName
func (p *ClientServiceClient) RenameTable(ns Namespace, name string, new_name string) (e *ClientException, err error) {
	if err = p.sendRenameTable(ns, name, new_name); err != nil {
		return
	}
	return p.recvRenameTable()
}

func (p *ClientServiceClient) sendRenameTable(ns Namespace, name string, new_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("rename_table", thrift.CALL, p.SeqId)
	args488 := NewRenameTableArgs()
	args488.Ns = ns
	args488.Name = name
	args488.NewName = new_name
	err = args488.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvRenameTable() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error490 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error491 error
		error491, err = error490.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error491
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result489 := NewRenameTableResult()
	err = result489.Read(iprot)
	iprot.ReadMessageEnd()
	if result489.E != nil {
		e = result489.E
	}
	return
}

// Parameters:
//  - Ns
//  - Name
//  - NewName
func (p *ClientServiceClient) TableRename(ns Namespace, name string, new_name string) (e *ClientException, err error) {
	if err = p.sendTableRename(ns, name, new_name); err != nil {
		return
	}
	return p.recvTableRename()
}

func (p *ClientServiceClient) sendTableRename(ns Namespace, name string, new_name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_rename", thrift.CALL, p.SeqId)
	args492 := NewTableRenameArgs()
	args492.Ns = ns
	args492.Name = name
	args492.NewName = new_name
	err = args492.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableRename() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error494 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error495 error
		error495, err = error494.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error495
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result493 := NewTableRenameResult()
	err = result493.Read(iprot)
	iprot.ReadMessageEnd()
	if result493.E != nil {
		e = result493.E
	}
	return
}

// Drop a table
//
// @param ns - namespace id
//
// @param name - table name
//
// @param if_exists - if true, don't barf if the table doesn't exist
//
// Parameters:
//  - Ns
//  - Name
//  - IfExists
func (p *ClientServiceClient) DropTable(ns Namespace, name string, if_exists bool) (e *ClientException, err error) {
	if err = p.sendDropTable(ns, name, if_exists); err != nil {
		return
	}
	return p.recvDropTable()
}

func (p *ClientServiceClient) sendDropTable(ns Namespace, name string, if_exists bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("drop_table", thrift.CALL, p.SeqId)
	args496 := NewDropTableArgs()
	args496.Ns = ns
	args496.Name = name
	args496.IfExists = if_exists
	err = args496.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvDropTable() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error498 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error499 error
		error499, err = error498.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error499
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result497 := NewDropTableResult()
	err = result497.Read(iprot)
	iprot.ReadMessageEnd()
	if result497.E != nil {
		e = result497.E
	}
	return
}

// Parameters:
//  - Ns
//  - Name
//  - IfExists
func (p *ClientServiceClient) TableDrop(ns Namespace, name string, if_exists bool) (e *ClientException, err error) {
	if err = p.sendTableDrop(ns, name, if_exists); err != nil {
		return
	}
	return p.recvTableDrop()
}

func (p *ClientServiceClient) sendTableDrop(ns Namespace, name string, if_exists bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("table_drop", thrift.CALL, p.SeqId)
	args500 := NewTableDropArgs()
	args500.Ns = ns
	args500.Name = name
	args500.IfExists = if_exists
	err = args500.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvTableDrop() (e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error502 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error503 error
		error503, err = error502.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error503
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result501 := NewTableDropResult()
	err = result501.Read(iprot)
	iprot.ReadMessageEnd()
	if result501.E != nil {
		e = result501.E
	}
	return
}

// Generate a GUID
//
// GUIDs are globally unique. The generated string is 36 bytes long and
// has a format similar to "9cf7da31-307a-4bef-b65e-19fb05aa57d8".
func (p *ClientServiceClient) GenerateGuid() (r string, err error) {
	if err = p.sendGenerateGuid(); err != nil {
		return
	}
	return p.recvGenerateGuid()
}

func (p *ClientServiceClient) sendGenerateGuid() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("generate_guid", thrift.CALL, p.SeqId)
	args504 := NewGenerateGuidArgs()
	err = args504.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvGenerateGuid() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error506 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error507 error
		error507, err = error506.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error507
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result505 := NewGenerateGuidResult()
	err = result505.Read(iprot)
	iprot.ReadMessageEnd()
	value = result505.Success
	return
}

// Inserts a unique value into a table
//
// This function inserts a unique value into a table. The table must be
// created with TIME_ORDER DESC, MAX_VERSIONS 1 (although the latter is
// optional).
//
// If the value is empty then a new GUID will be assigned
// (using @a generate_guid).
//
// @param ns - namespace id
// @param table_name - table name
// @param key - the Key of the value
// @param value - the unique value. Can be empty; in this case a new
//    guid will be generated internally
//
// @return the inserted unique value (which is identical to the @a value
//    parameter or a new guid, if value is empty)
//
// Parameters:
//  - Ns
//  - TableName
//  - Key
//  - Value
func (p *ClientServiceClient) CreateCellUnique(ns Namespace, table_name string, key *Key, value string) (r string, e *ClientException, err error) {
	if err = p.sendCreateCellUnique(ns, table_name, key, value); err != nil {
		return
	}
	return p.recvCreateCellUnique()
}

func (p *ClientServiceClient) sendCreateCellUnique(ns Namespace, table_name string, key *Key, value string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("create_cell_unique", thrift.CALL, p.SeqId)
	args508 := NewCreateCellUniqueArgs()
	args508.Ns = ns
	args508.TableName = table_name
	args508.Key = key
	args508.Value = value
	err = args508.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvCreateCellUnique() (value string, e *ClientException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error510 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error511 error
		error511, err = error510.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error511
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result509 := NewCreateCellUniqueResult()
	err = result509.Read(iprot)
	iprot.ReadMessageEnd()
	value = result509.Success
	if result509.E != nil {
		e = result509.E
	}
	return
}

// Retrieves a descriptive error string from an error code
//
// @param error_code - the numeric error code
//
// @return the descriptive string, or "ERROR NOT REGISTERED" if the error
//    code is unknown
//
// Parameters:
//  - ErrorCode
func (p *ClientServiceClient) ErrorGetText(error_code int32) (r string, err error) {
	if err = p.sendErrorGetText(error_code); err != nil {
		return
	}
	return p.recvErrorGetText()
}

func (p *ClientServiceClient) sendErrorGetText(error_code int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("error_get_text", thrift.CALL, p.SeqId)
	args512 := NewErrorGetTextArgs()
	args512.ErrorCode = error_code
	err = args512.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *ClientServiceClient) recvErrorGetText() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error514 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error515 error
		error515, err = error514.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error515
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result513 := NewErrorGetTextResult()
	err = result513.Read(iprot)
	iprot.ReadMessageEnd()
	value = result513.Success
	return
}

type ClientServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ClientService
}

func (p *ClientServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ClientServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ClientServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewClientServiceProcessor(handler ClientService) *ClientServiceProcessor {

	self516 := &ClientServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self516.processorMap["namespace_create"] = &clientServiceProcessorNamespaceCreate{handler: handler}
	self516.processorMap["create_namespace"] = &clientServiceProcessorCreateNamespace{handler: handler}
	self516.processorMap["create_table"] = &clientServiceProcessorCreateTable{handler: handler}
	self516.processorMap["table_create"] = &clientServiceProcessorTableCreate{handler: handler}
	self516.processorMap["alter_table"] = &clientServiceProcessorAlterTable{handler: handler}
	self516.processorMap["table_alter"] = &clientServiceProcessorTableAlter{handler: handler}
	self516.processorMap["refresh_table"] = &clientServiceProcessorRefreshTable{handler: handler}
	self516.processorMap["namespace_open"] = &clientServiceProcessorNamespaceOpen{handler: handler}
	self516.processorMap["open_namespace"] = &clientServiceProcessorOpenNamespace{handler: handler}
	self516.processorMap["namespace_close"] = &clientServiceProcessorNamespaceClose{handler: handler}
	self516.processorMap["close_namespace"] = &clientServiceProcessorCloseNamespace{handler: handler}
	self516.processorMap["future_open"] = &clientServiceProcessorFutureOpen{handler: handler}
	self516.processorMap["open_future"] = &clientServiceProcessorOpenFuture{handler: handler}
	self516.processorMap["future_cancel"] = &clientServiceProcessorFutureCancel{handler: handler}
	self516.processorMap["cancel_future"] = &clientServiceProcessorCancelFuture{handler: handler}
	self516.processorMap["future_get_result"] = &clientServiceProcessorFutureGetResult{handler: handler}
	self516.processorMap["get_future_result"] = &clientServiceProcessorGetFutureResult{handler: handler}
	self516.processorMap["future_get_result_as_arrays"] = &clientServiceProcessorFutureGetResultAsArrays{handler: handler}
	self516.processorMap["get_future_result_as_arrays"] = &clientServiceProcessorGetFutureResultAsArrays{handler: handler}
	self516.processorMap["future_get_result_serialized"] = &clientServiceProcessorFutureGetResultSerialized{handler: handler}
	self516.processorMap["get_future_result_serialized"] = &clientServiceProcessorGetFutureResultSerialized{handler: handler}
	self516.processorMap["future_is_empty"] = &clientServiceProcessorFutureIsEmpty{handler: handler}
	self516.processorMap["future_is_full"] = &clientServiceProcessorFutureIsFull{handler: handler}
	self516.processorMap["future_is_cancelled"] = &clientServiceProcessorFutureIsCancelled{handler: handler}
	self516.processorMap["future_has_outstanding"] = &clientServiceProcessorFutureHasOutstanding{handler: handler}
	self516.processorMap["future_close"] = &clientServiceProcessorFutureClose{handler: handler}
	self516.processorMap["close_future"] = &clientServiceProcessorCloseFuture{handler: handler}
	self516.processorMap["scanner_open"] = &clientServiceProcessorScannerOpen{handler: handler}
	self516.processorMap["open_scanner"] = &clientServiceProcessorOpenScanner{handler: handler}
	self516.processorMap["async_scanner_open"] = &clientServiceProcessorAsyncScannerOpen{handler: handler}
	self516.processorMap["open_scanner_async"] = &clientServiceProcessorOpenScannerAsync{handler: handler}
	self516.processorMap["scanner_close"] = &clientServiceProcessorScannerClose{handler: handler}
	self516.processorMap["close_scanner"] = &clientServiceProcessorCloseScanner{handler: handler}
	self516.processorMap["async_scanner_cancel"] = &clientServiceProcessorAsyncScannerCancel{handler: handler}
	self516.processorMap["cancel_scanner_async"] = &clientServiceProcessorCancelScannerAsync{handler: handler}
	self516.processorMap["async_scanner_close"] = &clientServiceProcessorAsyncScannerClose{handler: handler}
	self516.processorMap["close_scanner_async"] = &clientServiceProcessorCloseScannerAsync{handler: handler}
	self516.processorMap["scanner_get_cells"] = &clientServiceProcessorScannerGetCells{handler: handler}
	self516.processorMap["next_cells"] = &clientServiceProcessorNextCells{handler: handler}
	self516.processorMap["scanner_get_cells_as_arrays"] = &clientServiceProcessorScannerGetCellsAsArrays{handler: handler}
	self516.processorMap["next_cells_as_arrays"] = &clientServiceProcessorNextCellsAsArrays{handler: handler}
	self516.processorMap["scanner_get_cells_serialized"] = &clientServiceProcessorScannerGetCellsSerialized{handler: handler}
	self516.processorMap["next_cells_serialized"] = &clientServiceProcessorNextCellsSerialized{handler: handler}
	self516.processorMap["scanner_get_row"] = &clientServiceProcessorScannerGetRow{handler: handler}
	self516.processorMap["next_row"] = &clientServiceProcessorNextRow{handler: handler}
	self516.processorMap["scanner_get_row_as_arrays"] = &clientServiceProcessorScannerGetRowAsArrays{handler: handler}
	self516.processorMap["next_row_as_arrays"] = &clientServiceProcessorNextRowAsArrays{handler: handler}
	self516.processorMap["scanner_get_row_serialized"] = &clientServiceProcessorScannerGetRowSerialized{handler: handler}
	self516.processorMap["next_row_serialized"] = &clientServiceProcessorNextRowSerialized{handler: handler}
	self516.processorMap["get_row"] = &clientServiceProcessorGetRow{handler: handler}
	self516.processorMap["get_row_as_arrays"] = &clientServiceProcessorGetRowAsArrays{handler: handler}
	self516.processorMap["get_row_serialized"] = &clientServiceProcessorGetRowSerialized{handler: handler}
	self516.processorMap["get_cell"] = &clientServiceProcessorGetCell{handler: handler}
	self516.processorMap["get_cells"] = &clientServiceProcessorGetCells{handler: handler}
	self516.processorMap["get_cells_as_arrays"] = &clientServiceProcessorGetCellsAsArrays{handler: handler}
	self516.processorMap["get_cells_serialized"] = &clientServiceProcessorGetCellsSerialized{handler: handler}
	self516.processorMap["shared_mutator_refresh"] = &clientServiceProcessorSharedMutatorRefresh{handler: handler}
	self516.processorMap["refresh_shared_mutator"] = &clientServiceProcessorRefreshSharedMutator{handler: handler}
	self516.processorMap["shared_mutator_set_cells"] = &clientServiceProcessorSharedMutatorSetCells{handler: handler}
	self516.processorMap["offer_cells"] = &clientServiceProcessorOfferCells{handler: handler}
	self516.processorMap["shared_mutator_set_cells_as_arrays"] = &clientServiceProcessorSharedMutatorSetCellsAsArrays{handler: handler}
	self516.processorMap["offer_cells_as_arrays"] = &clientServiceProcessorOfferCellsAsArrays{handler: handler}
	self516.processorMap["shared_mutator_set_cell"] = &clientServiceProcessorSharedMutatorSetCell{handler: handler}
	self516.processorMap["offer_cell"] = &clientServiceProcessorOfferCell{handler: handler}
	self516.processorMap["shared_mutator_set_cell_as_array"] = &clientServiceProcessorSharedMutatorSetCellAsArray{handler: handler}
	self516.processorMap["offer_cell_as_array"] = &clientServiceProcessorOfferCellAsArray{handler: handler}
	self516.processorMap["mutator_open"] = &clientServiceProcessorMutatorOpen{handler: handler}
	self516.processorMap["open_mutator"] = &clientServiceProcessorOpenMutator{handler: handler}
	self516.processorMap["async_mutator_open"] = &clientServiceProcessorAsyncMutatorOpen{handler: handler}
	self516.processorMap["open_mutator_async"] = &clientServiceProcessorOpenMutatorAsync{handler: handler}
	self516.processorMap["mutator_close"] = &clientServiceProcessorMutatorClose{handler: handler}
	self516.processorMap["close_mutator"] = &clientServiceProcessorCloseMutator{handler: handler}
	self516.processorMap["async_mutator_cancel"] = &clientServiceProcessorAsyncMutatorCancel{handler: handler}
	self516.processorMap["cancel_mutator_async"] = &clientServiceProcessorCancelMutatorAsync{handler: handler}
	self516.processorMap["async_mutator_close"] = &clientServiceProcessorAsyncMutatorClose{handler: handler}
	self516.processorMap["close_mutator_async"] = &clientServiceProcessorCloseMutatorAsync{handler: handler}
	self516.processorMap["mutator_set_cell"] = &clientServiceProcessorMutatorSetCell{handler: handler}
	self516.processorMap["set_cell"] = &clientServiceProcessorSetCell{handler: handler}
	self516.processorMap["mutator_set_cell_as_array"] = &clientServiceProcessorMutatorSetCellAsArray{handler: handler}
	self516.processorMap["set_cell_as_array"] = &clientServiceProcessorSetCellAsArray{handler: handler}
	self516.processorMap["mutator_set_cells"] = &clientServiceProcessorMutatorSetCells{handler: handler}
	self516.processorMap["set_cells"] = &clientServiceProcessorSetCells{handler: handler}
	self516.processorMap["mutator_set_cells_as_arrays"] = &clientServiceProcessorMutatorSetCellsAsArrays{handler: handler}
	self516.processorMap["set_cells_as_arrays"] = &clientServiceProcessorSetCellsAsArrays{handler: handler}
	self516.processorMap["mutator_set_cells_serialized"] = &clientServiceProcessorMutatorSetCellsSerialized{handler: handler}
	self516.processorMap["set_cells_serialized"] = &clientServiceProcessorSetCellsSerialized{handler: handler}
	self516.processorMap["mutator_flush"] = &clientServiceProcessorMutatorFlush{handler: handler}
	self516.processorMap["flush_mutator"] = &clientServiceProcessorFlushMutator{handler: handler}
	self516.processorMap["async_mutator_set_cell"] = &clientServiceProcessorAsyncMutatorSetCell{handler: handler}
	self516.processorMap["set_cell_async"] = &clientServiceProcessorSetCellAsync{handler: handler}
	self516.processorMap["async_mutator_set_cell_as_array"] = &clientServiceProcessorAsyncMutatorSetCellAsArray{handler: handler}
	self516.processorMap["set_cell_as_array_async"] = &clientServiceProcessorSetCellAsArrayAsync{handler: handler}
	self516.processorMap["async_mutator_set_cells"] = &clientServiceProcessorAsyncMutatorSetCells{handler: handler}
	self516.processorMap["set_cells_async"] = &clientServiceProcessorSetCellsAsync{handler: handler}
	self516.processorMap["async_mutator_set_cells_as_arrays"] = &clientServiceProcessorAsyncMutatorSetCellsAsArrays{handler: handler}
	self516.processorMap["set_cells_as_arrays_async"] = &clientServiceProcessorSetCellsAsArraysAsync{handler: handler}
	self516.processorMap["async_mutator_set_cells_serialized"] = &clientServiceProcessorAsyncMutatorSetCellsSerialized{handler: handler}
	self516.processorMap["set_cells_serialized_async"] = &clientServiceProcessorSetCellsSerializedAsync{handler: handler}
	self516.processorMap["async_mutator_flush"] = &clientServiceProcessorAsyncMutatorFlush{handler: handler}
	self516.processorMap["flush_mutator_async"] = &clientServiceProcessorFlushMutatorAsync{handler: handler}
	self516.processorMap["namespace_exists"] = &clientServiceProcessorNamespaceExists{handler: handler}
	self516.processorMap["exists_namespace"] = &clientServiceProcessorExistsNamespace{handler: handler}
	self516.processorMap["exists_table"] = &clientServiceProcessorExistsTable{handler: handler}
	self516.processorMap["table_exists"] = &clientServiceProcessorTableExists{handler: handler}
	self516.processorMap["table_get_id"] = &clientServiceProcessorTableGetId{handler: handler}
	self516.processorMap["get_table_id"] = &clientServiceProcessorGetTableId{handler: handler}
	self516.processorMap["table_get_schema_str"] = &clientServiceProcessorTableGetSchemaStr{handler: handler}
	self516.processorMap["get_schema_str"] = &clientServiceProcessorGetSchemaStr{handler: handler}
	self516.processorMap["table_get_schema_str_with_ids"] = &clientServiceProcessorTableGetSchemaStrWithIds{handler: handler}
	self516.processorMap["get_schema_str_with_ids"] = &clientServiceProcessorGetSchemaStrWithIds{handler: handler}
	self516.processorMap["table_get_schema"] = &clientServiceProcessorTableGetSchema{handler: handler}
	self516.processorMap["get_schema"] = &clientServiceProcessorGetSchema{handler: handler}
	self516.processorMap["get_tables"] = &clientServiceProcessorGetTables{handler: handler}
	self516.processorMap["namespace_get_listing"] = &clientServiceProcessorNamespaceGetListing{handler: handler}
	self516.processorMap["get_listing"] = &clientServiceProcessorGetListing{handler: handler}
	self516.processorMap["table_get_splits"] = &clientServiceProcessorTableGetSplits{handler: handler}
	self516.processorMap["get_table_splits"] = &clientServiceProcessorGetTableSplits{handler: handler}
	self516.processorMap["namespace_drop"] = &clientServiceProcessorNamespaceDrop{handler: handler}
	self516.processorMap["drop_namespace"] = &clientServiceProcessorDropNamespace{handler: handler}
	self516.processorMap["rename_table"] = &clientServiceProcessorRenameTable{handler: handler}
	self516.processorMap["table_rename"] = &clientServiceProcessorTableRename{handler: handler}
	self516.processorMap["drop_table"] = &clientServiceProcessorDropTable{handler: handler}
	self516.processorMap["table_drop"] = &clientServiceProcessorTableDrop{handler: handler}
	self516.processorMap["generate_guid"] = &clientServiceProcessorGenerateGuid{handler: handler}
	self516.processorMap["create_cell_unique"] = &clientServiceProcessorCreateCellUnique{handler: handler}
	self516.processorMap["error_get_text"] = &clientServiceProcessorErrorGetText{handler: handler}
	return self516
}

func (p *ClientServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x517 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x517.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x517

}

type clientServiceProcessorNamespaceCreate struct {
	handler ClientService
}

func (p *clientServiceProcessorNamespaceCreate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNamespaceCreateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("namespace_create", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNamespaceCreateResult()
	if result.E, err = p.handler.NamespaceCreate(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing namespace_create: "+err.Error())
		oprot.WriteMessageBegin("namespace_create", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("namespace_create", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCreateNamespace struct {
	handler ClientService
}

func (p *clientServiceProcessorCreateNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateNamespaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("create_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCreateNamespaceResult()
	if result.E, err = p.handler.CreateNamespace(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing create_namespace: "+err.Error())
		oprot.WriteMessageBegin("create_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("create_namespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCreateTable struct {
	handler ClientService
}

func (p *clientServiceProcessorCreateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("create_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCreateTableResult()
	if result.E, err = p.handler.CreateTable(args.Ns, args.TableName, args.Schema); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing create_table: "+err.Error())
		oprot.WriteMessageBegin("create_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("create_table", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableCreate struct {
	handler ClientService
}

func (p *clientServiceProcessorTableCreate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableCreateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_create", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableCreateResult()
	if result.E, err = p.handler.TableCreate(args.Ns, args.TableName, args.Schema); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_create: "+err.Error())
		oprot.WriteMessageBegin("table_create", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_create", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAlterTable struct {
	handler ClientService
}

func (p *clientServiceProcessorAlterTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAlterTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("alter_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAlterTableResult()
	if result.E, err = p.handler.AlterTable(args.Ns, args.TableName, args.Schema); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing alter_table: "+err.Error())
		oprot.WriteMessageBegin("alter_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("alter_table", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableAlter struct {
	handler ClientService
}

func (p *clientServiceProcessorTableAlter) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableAlterArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_alter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableAlterResult()
	if result.E, err = p.handler.TableAlter(args.Ns, args.TableName, args.Schema); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_alter: "+err.Error())
		oprot.WriteMessageBegin("table_alter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_alter", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorRefreshTable struct {
	handler ClientService
}

func (p *clientServiceProcessorRefreshTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRefreshTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("refresh_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRefreshTableResult()
	if result.E, err = p.handler.RefreshTable(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing refresh_table: "+err.Error())
		oprot.WriteMessageBegin("refresh_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("refresh_table", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNamespaceOpen struct {
	handler ClientService
}

func (p *clientServiceProcessorNamespaceOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNamespaceOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("namespace_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNamespaceOpenResult()
	if result.Success, result.E, err = p.handler.NamespaceOpen(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing namespace_open: "+err.Error())
		oprot.WriteMessageBegin("namespace_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("namespace_open", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOpenNamespace struct {
	handler ClientService
}

func (p *clientServiceProcessorOpenNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenNamespaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("open_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOpenNamespaceResult()
	if result.Success, result.E, err = p.handler.OpenNamespace(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing open_namespace: "+err.Error())
		oprot.WriteMessageBegin("open_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("open_namespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNamespaceClose struct {
	handler ClientService
}

func (p *clientServiceProcessorNamespaceClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNamespaceCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("namespace_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNamespaceCloseResult()
	if result.E, err = p.handler.NamespaceClose(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing namespace_close: "+err.Error())
		oprot.WriteMessageBegin("namespace_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("namespace_close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCloseNamespace struct {
	handler ClientService
}

func (p *clientServiceProcessorCloseNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseNamespaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCloseNamespaceResult()
	if result.E, err = p.handler.CloseNamespace(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close_namespace: "+err.Error())
		oprot.WriteMessageBegin("close_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("close_namespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureOpen struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureOpenResult()
	if result.Success, result.E, err = p.handler.FutureOpen(args.Capacity); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_open: "+err.Error())
		oprot.WriteMessageBegin("future_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_open", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOpenFuture struct {
	handler ClientService
}

func (p *clientServiceProcessorOpenFuture) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenFutureArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("open_future", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOpenFutureResult()
	if result.Success, result.E, err = p.handler.OpenFuture(args.Capacity); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing open_future: "+err.Error())
		oprot.WriteMessageBegin("open_future", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("open_future", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureCancel struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureCancel) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureCancelArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_cancel", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureCancelResult()
	if result.E, err = p.handler.FutureCancel(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_cancel: "+err.Error())
		oprot.WriteMessageBegin("future_cancel", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_cancel", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCancelFuture struct {
	handler ClientService
}

func (p *clientServiceProcessorCancelFuture) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCancelFutureArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("cancel_future", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCancelFutureResult()
	if result.E, err = p.handler.CancelFuture(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancel_future: "+err.Error())
		oprot.WriteMessageBegin("cancel_future", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("cancel_future", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureGetResult struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureGetResult) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureGetResultArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_get_result", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureGetResultResult()
	if result.Success, result.E, err = p.handler.FutureGetResult(args.Ff, args.TimeoutMillis); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_get_result: "+err.Error())
		oprot.WriteMessageBegin("future_get_result", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_get_result", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetFutureResult struct {
	handler ClientService
}

func (p *clientServiceProcessorGetFutureResult) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetFutureResultArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_future_result", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetFutureResultResult()
	if result.Success, result.E, err = p.handler.GetFutureResult(args.Ff, args.TimeoutMillis); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_future_result: "+err.Error())
		oprot.WriteMessageBegin("get_future_result", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_future_result", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureGetResultAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureGetResultAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureGetResultAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_get_result_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureGetResultAsArraysResult()
	if result.Success, result.E, err = p.handler.FutureGetResultAsArrays(args.Ff, args.TimeoutMillis); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_get_result_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("future_get_result_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_get_result_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetFutureResultAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorGetFutureResultAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetFutureResultAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_future_result_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetFutureResultAsArraysResult()
	if result.Success, result.E, err = p.handler.GetFutureResultAsArrays(args.Ff, args.TimeoutMillis); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_future_result_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("get_future_result_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_future_result_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureGetResultSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureGetResultSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureGetResultSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_get_result_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureGetResultSerializedResult()
	if result.Success, result.E, err = p.handler.FutureGetResultSerialized(args.Ff, args.TimeoutMillis); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_get_result_serialized: "+err.Error())
		oprot.WriteMessageBegin("future_get_result_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_get_result_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetFutureResultSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorGetFutureResultSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetFutureResultSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_future_result_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetFutureResultSerializedResult()
	if result.Success, result.E, err = p.handler.GetFutureResultSerialized(args.Ff, args.TimeoutMillis); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_future_result_serialized: "+err.Error())
		oprot.WriteMessageBegin("get_future_result_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_future_result_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureIsEmpty struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureIsEmpty) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureIsEmptyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_is_empty", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureIsEmptyResult()
	if result.Success, result.E, err = p.handler.FutureIsEmpty(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_is_empty: "+err.Error())
		oprot.WriteMessageBegin("future_is_empty", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_is_empty", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureIsFull struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureIsFull) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureIsFullArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_is_full", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureIsFullResult()
	if result.Success, result.E, err = p.handler.FutureIsFull(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_is_full: "+err.Error())
		oprot.WriteMessageBegin("future_is_full", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_is_full", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureIsCancelled struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureIsCancelled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureIsCancelledArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_is_cancelled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureIsCancelledResult()
	if result.Success, result.E, err = p.handler.FutureIsCancelled(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_is_cancelled: "+err.Error())
		oprot.WriteMessageBegin("future_is_cancelled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_is_cancelled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureHasOutstanding struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureHasOutstanding) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureHasOutstandingArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_has_outstanding", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureHasOutstandingResult()
	if result.Success, result.E, err = p.handler.FutureHasOutstanding(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_has_outstanding: "+err.Error())
		oprot.WriteMessageBegin("future_has_outstanding", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_has_outstanding", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFutureClose struct {
	handler ClientService
}

func (p *clientServiceProcessorFutureClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFutureCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("future_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFutureCloseResult()
	if result.E, err = p.handler.FutureClose(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing future_close: "+err.Error())
		oprot.WriteMessageBegin("future_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("future_close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCloseFuture struct {
	handler ClientService
}

func (p *clientServiceProcessorCloseFuture) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseFutureArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close_future", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCloseFutureResult()
	if result.E, err = p.handler.CloseFuture(args.Ff); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close_future: "+err.Error())
		oprot.WriteMessageBegin("close_future", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("close_future", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerOpen struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerOpenResult()
	if result.Success, result.E, err = p.handler.ScannerOpen(args.Ns, args.TableName, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_open: "+err.Error())
		oprot.WriteMessageBegin("scanner_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_open", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOpenScanner struct {
	handler ClientService
}

func (p *clientServiceProcessorOpenScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenScannerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("open_scanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOpenScannerResult()
	if result.Success, result.E, err = p.handler.OpenScanner(args.Ns, args.TableName, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing open_scanner: "+err.Error())
		oprot.WriteMessageBegin("open_scanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("open_scanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncScannerOpen struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncScannerOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncScannerOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_scanner_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncScannerOpenResult()
	if result.Success, result.E, err = p.handler.AsyncScannerOpen(args.Ns, args.TableName, args.Future, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_scanner_open: "+err.Error())
		oprot.WriteMessageBegin("async_scanner_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_scanner_open", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOpenScannerAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorOpenScannerAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenScannerAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("open_scanner_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOpenScannerAsyncResult()
	if result.Success, result.E, err = p.handler.OpenScannerAsync(args.Ns, args.TableName, args.Future, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing open_scanner_async: "+err.Error())
		oprot.WriteMessageBegin("open_scanner_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("open_scanner_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerClose struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerCloseResult()
	if result.E, err = p.handler.ScannerClose(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_close: "+err.Error())
		oprot.WriteMessageBegin("scanner_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCloseScanner struct {
	handler ClientService
}

func (p *clientServiceProcessorCloseScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseScannerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close_scanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCloseScannerResult()
	if result.E, err = p.handler.CloseScanner(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close_scanner: "+err.Error())
		oprot.WriteMessageBegin("close_scanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("close_scanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncScannerCancel struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncScannerCancel) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncScannerCancelArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_scanner_cancel", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncScannerCancelResult()
	if result.E, err = p.handler.AsyncScannerCancel(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_scanner_cancel: "+err.Error())
		oprot.WriteMessageBegin("async_scanner_cancel", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_scanner_cancel", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCancelScannerAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorCancelScannerAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCancelScannerAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("cancel_scanner_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCancelScannerAsyncResult()
	if result.E, err = p.handler.CancelScannerAsync(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancel_scanner_async: "+err.Error())
		oprot.WriteMessageBegin("cancel_scanner_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("cancel_scanner_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncScannerClose struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncScannerClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncScannerCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_scanner_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncScannerCloseResult()
	if result.E, err = p.handler.AsyncScannerClose(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_scanner_close: "+err.Error())
		oprot.WriteMessageBegin("async_scanner_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_scanner_close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCloseScannerAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorCloseScannerAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseScannerAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close_scanner_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCloseScannerAsyncResult()
	if result.E, err = p.handler.CloseScannerAsync(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close_scanner_async: "+err.Error())
		oprot.WriteMessageBegin("close_scanner_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("close_scanner_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerGetCells struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerGetCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_get_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetCellsResult()
	if result.Success, result.E, err = p.handler.ScannerGetCells(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_get_cells: "+err.Error())
		oprot.WriteMessageBegin("scanner_get_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_get_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNextCells struct {
	handler ClientService
}

func (p *clientServiceProcessorNextCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNextCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("next_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNextCellsResult()
	if result.Success, result.E, err = p.handler.NextCells(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing next_cells: "+err.Error())
		oprot.WriteMessageBegin("next_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("next_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerGetCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerGetCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_get_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetCellsAsArraysResult()
	if result.Success, result.E, err = p.handler.ScannerGetCellsAsArrays(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_get_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("scanner_get_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_get_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNextCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorNextCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNextCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("next_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNextCellsAsArraysResult()
	if result.Success, result.E, err = p.handler.NextCellsAsArrays(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing next_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("next_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("next_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerGetCellsSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerGetCellsSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetCellsSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_get_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetCellsSerializedResult()
	if result.Success, result.E, err = p.handler.ScannerGetCellsSerialized(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_get_cells_serialized: "+err.Error())
		oprot.WriteMessageBegin("scanner_get_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_get_cells_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNextCellsSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorNextCellsSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNextCellsSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("next_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNextCellsSerializedResult()
	if result.Success, result.E, err = p.handler.NextCellsSerialized(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing next_cells_serialized: "+err.Error())
		oprot.WriteMessageBegin("next_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("next_cells_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerGetRow struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerGetRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_get_row", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetRowResult()
	if result.Success, result.E, err = p.handler.ScannerGetRow(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_get_row: "+err.Error())
		oprot.WriteMessageBegin("scanner_get_row", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_get_row", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNextRow struct {
	handler ClientService
}

func (p *clientServiceProcessorNextRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNextRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("next_row", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNextRowResult()
	if result.Success, result.E, err = p.handler.NextRow(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing next_row: "+err.Error())
		oprot.WriteMessageBegin("next_row", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("next_row", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerGetRowAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerGetRowAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetRowAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_get_row_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetRowAsArraysResult()
	if result.Success, result.E, err = p.handler.ScannerGetRowAsArrays(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_get_row_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("scanner_get_row_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_get_row_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNextRowAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorNextRowAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNextRowAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("next_row_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNextRowAsArraysResult()
	if result.Success, result.E, err = p.handler.NextRowAsArrays(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing next_row_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("next_row_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("next_row_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorScannerGetRowSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorScannerGetRowSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewScannerGetRowSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scanner_get_row_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewScannerGetRowSerializedResult()
	if result.Success, result.E, err = p.handler.ScannerGetRowSerialized(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scanner_get_row_serialized: "+err.Error())
		oprot.WriteMessageBegin("scanner_get_row_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("scanner_get_row_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNextRowSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorNextRowSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNextRowSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("next_row_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNextRowSerializedResult()
	if result.Success, result.E, err = p.handler.NextRowSerialized(args.Scanner); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing next_row_serialized: "+err.Error())
		oprot.WriteMessageBegin("next_row_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("next_row_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetRow struct {
	handler ClientService
}

func (p *clientServiceProcessorGetRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_row", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowResult()
	if result.Success, result.E, err = p.handler.GetRow(args.Ns, args.TableName, args.Row); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_row: "+err.Error())
		oprot.WriteMessageBegin("get_row", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_row", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetRowAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorGetRowAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_row_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowAsArraysResult()
	if result.Success, result.E, err = p.handler.GetRowAsArrays(args.Ns, args.Name, args.Row); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_row_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("get_row_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_row_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetRowSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorGetRowSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRowSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_row_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRowSerializedResult()
	if result.Success, result.E, err = p.handler.GetRowSerialized(args.Ns, args.TableName, args.Row); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_row_serialized: "+err.Error())
		oprot.WriteMessageBegin("get_row_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_row_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetCell struct {
	handler ClientService
}

func (p *clientServiceProcessorGetCell) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetCellArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetCellResult()
	if result.Success, result.E, err = p.handler.GetCell(args.Ns, args.TableName, args.Row, args.Column); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_cell: "+err.Error())
		oprot.WriteMessageBegin("get_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_cell", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetCells struct {
	handler ClientService
}

func (p *clientServiceProcessorGetCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetCellsResult()
	if result.Success, result.E, err = p.handler.GetCells(args.Ns, args.TableName, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_cells: "+err.Error())
		oprot.WriteMessageBegin("get_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorGetCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetCellsAsArraysResult()
	if result.Success, result.E, err = p.handler.GetCellsAsArrays(args.Ns, args.Name, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("get_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetCellsSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorGetCellsSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetCellsSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetCellsSerializedResult()
	if result.Success, result.E, err = p.handler.GetCellsSerialized(args.Ns, args.Name, args.ScanSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_cells_serialized: "+err.Error())
		oprot.WriteMessageBegin("get_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_cells_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSharedMutatorRefresh struct {
	handler ClientService
}

func (p *clientServiceProcessorSharedMutatorRefresh) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSharedMutatorRefreshArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("shared_mutator_refresh", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSharedMutatorRefreshResult()
	if result.E, err = p.handler.SharedMutatorRefresh(args.Ns, args.TableName, args.MutateSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shared_mutator_refresh: "+err.Error())
		oprot.WriteMessageBegin("shared_mutator_refresh", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("shared_mutator_refresh", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorRefreshSharedMutator struct {
	handler ClientService
}

func (p *clientServiceProcessorRefreshSharedMutator) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRefreshSharedMutatorArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("refresh_shared_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRefreshSharedMutatorResult()
	if result.E, err = p.handler.RefreshSharedMutator(args.Ns, args.TableName, args.MutateSpec); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing refresh_shared_mutator: "+err.Error())
		oprot.WriteMessageBegin("refresh_shared_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("refresh_shared_mutator", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSharedMutatorSetCells struct {
	handler ClientService
}

func (p *clientServiceProcessorSharedMutatorSetCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSharedMutatorSetCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSharedMutatorSetCellsResult()
	if result.E, err = p.handler.SharedMutatorSetCells(args.Ns, args.TableName, args.MutateSpec, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shared_mutator_set_cells: "+err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("shared_mutator_set_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOfferCells struct {
	handler ClientService
}

func (p *clientServiceProcessorOfferCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOfferCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("offer_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOfferCellsResult()
	if result.E, err = p.handler.OfferCells(args.Ns, args.TableName, args.MutateSpec, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing offer_cells: "+err.Error())
		oprot.WriteMessageBegin("offer_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("offer_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSharedMutatorSetCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorSharedMutatorSetCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSharedMutatorSetCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSharedMutatorSetCellsAsArraysResult()
	if result.E, err = p.handler.SharedMutatorSetCellsAsArrays(args.Ns, args.TableName, args.MutateSpec, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shared_mutator_set_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("shared_mutator_set_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOfferCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorOfferCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOfferCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("offer_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOfferCellsAsArraysResult()
	if result.E, err = p.handler.OfferCellsAsArrays(args.Ns, args.TableName, args.MutateSpec, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing offer_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("offer_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("offer_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSharedMutatorSetCell struct {
	handler ClientService
}

func (p *clientServiceProcessorSharedMutatorSetCell) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSharedMutatorSetCellArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSharedMutatorSetCellResult()
	if result.E, err = p.handler.SharedMutatorSetCell(args.Ns, args.TableName, args.MutateSpec, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shared_mutator_set_cell: "+err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("shared_mutator_set_cell", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOfferCell struct {
	handler ClientService
}

func (p *clientServiceProcessorOfferCell) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOfferCellArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("offer_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOfferCellResult()
	if result.E, err = p.handler.OfferCell(args.Ns, args.TableName, args.MutateSpec, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing offer_cell: "+err.Error())
		oprot.WriteMessageBegin("offer_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("offer_cell", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSharedMutatorSetCellAsArray struct {
	handler ClientService
}

func (p *clientServiceProcessorSharedMutatorSetCellAsArray) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSharedMutatorSetCellAsArrayArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSharedMutatorSetCellAsArrayResult()
	if result.E, err = p.handler.SharedMutatorSetCellAsArray(args.Ns, args.TableName, args.MutateSpec, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing shared_mutator_set_cell_as_array: "+err.Error())
		oprot.WriteMessageBegin("shared_mutator_set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("shared_mutator_set_cell_as_array", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOfferCellAsArray struct {
	handler ClientService
}

func (p *clientServiceProcessorOfferCellAsArray) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOfferCellAsArrayArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("offer_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOfferCellAsArrayResult()
	if result.E, err = p.handler.OfferCellAsArray(args.Ns, args.TableName, args.MutateSpec, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing offer_cell_as_array: "+err.Error())
		oprot.WriteMessageBegin("offer_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("offer_cell_as_array", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorOpen struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorOpenResult()
	if result.Success, result.E, err = p.handler.MutatorOpen(args.Ns, args.TableName, args.Flags, args.FlushInterval); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_open: "+err.Error())
		oprot.WriteMessageBegin("mutator_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_open", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOpenMutator struct {
	handler ClientService
}

func (p *clientServiceProcessorOpenMutator) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenMutatorArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("open_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOpenMutatorResult()
	if result.Success, result.E, err = p.handler.OpenMutator(args.Ns, args.TableName, args.Flags, args.FlushInterval); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing open_mutator: "+err.Error())
		oprot.WriteMessageBegin("open_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("open_mutator", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorOpen struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorOpen) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorOpenArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorOpenResult()
	if result.Success, result.E, err = p.handler.AsyncMutatorOpen(args.Ns, args.TableName, args.Future, args.Flags); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_open: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_open", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_open", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorOpenMutatorAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorOpenMutatorAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewOpenMutatorAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("open_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewOpenMutatorAsyncResult()
	if result.Success, result.E, err = p.handler.OpenMutatorAsync(args.Ns, args.TableName, args.Future, args.Flags); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing open_mutator_async: "+err.Error())
		oprot.WriteMessageBegin("open_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("open_mutator_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorClose struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorCloseResult()
	if result.E, err = p.handler.MutatorClose(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_close: "+err.Error())
		oprot.WriteMessageBegin("mutator_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCloseMutator struct {
	handler ClientService
}

func (p *clientServiceProcessorCloseMutator) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseMutatorArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCloseMutatorResult()
	if result.E, err = p.handler.CloseMutator(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close_mutator: "+err.Error())
		oprot.WriteMessageBegin("close_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("close_mutator", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorCancel struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorCancel) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorCancelArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_cancel", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorCancelResult()
	if result.E, err = p.handler.AsyncMutatorCancel(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_cancel: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_cancel", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_cancel", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCancelMutatorAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorCancelMutatorAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCancelMutatorAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("cancel_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCancelMutatorAsyncResult()
	if result.E, err = p.handler.CancelMutatorAsync(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cancel_mutator_async: "+err.Error())
		oprot.WriteMessageBegin("cancel_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("cancel_mutator_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorClose struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorCloseArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorCloseResult()
	if result.E, err = p.handler.AsyncMutatorClose(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_close: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCloseMutatorAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorCloseMutatorAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCloseMutatorAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCloseMutatorAsyncResult()
	if result.E, err = p.handler.CloseMutatorAsync(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close_mutator_async: "+err.Error())
		oprot.WriteMessageBegin("close_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("close_mutator_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorSetCell struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorSetCell) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorSetCellArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorSetCellResult()
	if result.E, err = p.handler.MutatorSetCell(args.Mutator, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_set_cell: "+err.Error())
		oprot.WriteMessageBegin("mutator_set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_set_cell", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCell struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCell) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellResult()
	if result.E, err = p.handler.SetCell(args.Ns, args.TableName, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cell: "+err.Error())
		oprot.WriteMessageBegin("set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cell", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorSetCellAsArray struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorSetCellAsArray) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorSetCellAsArrayArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorSetCellAsArrayResult()
	if result.E, err = p.handler.MutatorSetCellAsArray(args.Mutator, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_set_cell_as_array: "+err.Error())
		oprot.WriteMessageBegin("mutator_set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_set_cell_as_array", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellAsArray struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellAsArray) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellAsArrayArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellAsArrayResult()
	if result.E, err = p.handler.SetCellAsArray(args.Ns, args.TableName, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cell_as_array: "+err.Error())
		oprot.WriteMessageBegin("set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cell_as_array", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorSetCells struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorSetCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorSetCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorSetCellsResult()
	if result.E, err = p.handler.MutatorSetCells(args.Mutator, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_set_cells: "+err.Error())
		oprot.WriteMessageBegin("mutator_set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_set_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCells struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellsResult()
	if result.E, err = p.handler.SetCells(args.Ns, args.TableName, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cells: "+err.Error())
		oprot.WriteMessageBegin("set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorSetCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorSetCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorSetCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorSetCellsAsArraysResult()
	if result.E, err = p.handler.MutatorSetCellsAsArrays(args.Mutator, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_set_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("mutator_set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_set_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellsAsArraysResult()
	if result.E, err = p.handler.SetCellsAsArrays(args.Ns, args.TableName, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorSetCellsSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorSetCellsSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorSetCellsSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_set_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorSetCellsSerializedResult()
	if result.E, err = p.handler.MutatorSetCellsSerialized(args.Mutator, args.Cells, args.Flush); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_set_cells_serialized: "+err.Error())
		oprot.WriteMessageBegin("mutator_set_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_set_cells_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellsSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellsSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellsSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellsSerializedResult()
	if result.E, err = p.handler.SetCellsSerialized(args.Ns, args.TableName, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cells_serialized: "+err.Error())
		oprot.WriteMessageBegin("set_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cells_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorMutatorFlush struct {
	handler ClientService
}

func (p *clientServiceProcessorMutatorFlush) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMutatorFlushArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutator_flush", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMutatorFlushResult()
	if result.E, err = p.handler.MutatorFlush(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutator_flush: "+err.Error())
		oprot.WriteMessageBegin("mutator_flush", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("mutator_flush", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFlushMutator struct {
	handler ClientService
}

func (p *clientServiceProcessorFlushMutator) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFlushMutatorArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("flush_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFlushMutatorResult()
	if result.E, err = p.handler.FlushMutator(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing flush_mutator: "+err.Error())
		oprot.WriteMessageBegin("flush_mutator", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("flush_mutator", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorSetCell struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorSetCell) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorSetCellArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorSetCellResult()
	if result.E, err = p.handler.AsyncMutatorSetCell(args.Mutator, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_set_cell: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cell", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_set_cell", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cell_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellAsyncResult()
	if result.E, err = p.handler.SetCellAsync(args.Mutator, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cell_async: "+err.Error())
		oprot.WriteMessageBegin("set_cell_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cell_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorSetCellAsArray struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorSetCellAsArray) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorSetCellAsArrayArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorSetCellAsArrayResult()
	if result.E, err = p.handler.AsyncMutatorSetCellAsArray(args.Mutator, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_set_cell_as_array: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cell_as_array", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_set_cell_as_array", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellAsArrayAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellAsArrayAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellAsArrayAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cell_as_array_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellAsArrayAsyncResult()
	if result.E, err = p.handler.SetCellAsArrayAsync(args.Mutator, args.Cell); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cell_as_array_async: "+err.Error())
		oprot.WriteMessageBegin("set_cell_as_array_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cell_as_array_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorSetCells struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorSetCells) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorSetCellsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorSetCellsResult()
	if result.E, err = p.handler.AsyncMutatorSetCells(args.Mutator, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_set_cells: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cells", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_set_cells", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellsAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellsAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellsAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cells_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellsAsyncResult()
	if result.E, err = p.handler.SetCellsAsync(args.Mutator, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cells_async: "+err.Error())
		oprot.WriteMessageBegin("set_cells_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cells_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorSetCellsAsArrays struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorSetCellsAsArrays) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorSetCellsAsArraysArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorSetCellsAsArraysResult()
	if result.E, err = p.handler.AsyncMutatorSetCellsAsArrays(args.Mutator, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_set_cells_as_arrays: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cells_as_arrays", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_set_cells_as_arrays", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellsAsArraysAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellsAsArraysAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellsAsArraysAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cells_as_arrays_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellsAsArraysAsyncResult()
	if result.E, err = p.handler.SetCellsAsArraysAsync(args.Mutator, args.Cells); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cells_as_arrays_async: "+err.Error())
		oprot.WriteMessageBegin("set_cells_as_arrays_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cells_as_arrays_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorSetCellsSerialized struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorSetCellsSerialized) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorSetCellsSerializedArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorSetCellsSerializedResult()
	if result.E, err = p.handler.AsyncMutatorSetCellsSerialized(args.Mutator, args.Cells, args.Flush); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_set_cells_serialized: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_set_cells_serialized", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_set_cells_serialized", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorSetCellsSerializedAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorSetCellsSerializedAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCellsSerializedAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cells_serialized_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCellsSerializedAsyncResult()
	if result.E, err = p.handler.SetCellsSerializedAsync(args.Mutator, args.Cells, args.Flush); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cells_serialized_async: "+err.Error())
		oprot.WriteMessageBegin("set_cells_serialized_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cells_serialized_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorAsyncMutatorFlush struct {
	handler ClientService
}

func (p *clientServiceProcessorAsyncMutatorFlush) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAsyncMutatorFlushArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("async_mutator_flush", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAsyncMutatorFlushResult()
	if result.E, err = p.handler.AsyncMutatorFlush(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing async_mutator_flush: "+err.Error())
		oprot.WriteMessageBegin("async_mutator_flush", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("async_mutator_flush", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorFlushMutatorAsync struct {
	handler ClientService
}

func (p *clientServiceProcessorFlushMutatorAsync) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewFlushMutatorAsyncArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("flush_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewFlushMutatorAsyncResult()
	if result.E, err = p.handler.FlushMutatorAsync(args.Mutator); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing flush_mutator_async: "+err.Error())
		oprot.WriteMessageBegin("flush_mutator_async", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("flush_mutator_async", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNamespaceExists struct {
	handler ClientService
}

func (p *clientServiceProcessorNamespaceExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNamespaceExistsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("namespace_exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNamespaceExistsResult()
	if result.Success, result.E, err = p.handler.NamespaceExists(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing namespace_exists: "+err.Error())
		oprot.WriteMessageBegin("namespace_exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("namespace_exists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorExistsNamespace struct {
	handler ClientService
}

func (p *clientServiceProcessorExistsNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExistsNamespaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("exists_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExistsNamespaceResult()
	if result.Success, result.E, err = p.handler.ExistsNamespace(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists_namespace: "+err.Error())
		oprot.WriteMessageBegin("exists_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("exists_namespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorExistsTable struct {
	handler ClientService
}

func (p *clientServiceProcessorExistsTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExistsTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("exists_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExistsTableResult()
	if result.Success, result.E, err = p.handler.ExistsTable(args.Ns, args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists_table: "+err.Error())
		oprot.WriteMessageBegin("exists_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("exists_table", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableExists struct {
	handler ClientService
}

func (p *clientServiceProcessorTableExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableExistsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableExistsResult()
	if result.Success, result.E, err = p.handler.TableExists(args.Ns, args.Name); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_exists: "+err.Error())
		oprot.WriteMessageBegin("table_exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_exists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableGetId struct {
	handler ClientService
}

func (p *clientServiceProcessorTableGetId) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableGetIdArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_get_id", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableGetIdResult()
	if result.Success, result.E, err = p.handler.TableGetId(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_get_id: "+err.Error())
		oprot.WriteMessageBegin("table_get_id", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_get_id", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetTableId struct {
	handler ClientService
}

func (p *clientServiceProcessorGetTableId) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTableIdArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_table_id", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetTableIdResult()
	if result.Success, result.E, err = p.handler.GetTableId(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_table_id: "+err.Error())
		oprot.WriteMessageBegin("get_table_id", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_table_id", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableGetSchemaStr struct {
	handler ClientService
}

func (p *clientServiceProcessorTableGetSchemaStr) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableGetSchemaStrArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_get_schema_str", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableGetSchemaStrResult()
	if result.Success, result.E, err = p.handler.TableGetSchemaStr(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_get_schema_str: "+err.Error())
		oprot.WriteMessageBegin("table_get_schema_str", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_get_schema_str", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetSchemaStr struct {
	handler ClientService
}

func (p *clientServiceProcessorGetSchemaStr) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetSchemaStrArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_schema_str", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetSchemaStrResult()
	if result.Success, result.E, err = p.handler.GetSchemaStr(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_schema_str: "+err.Error())
		oprot.WriteMessageBegin("get_schema_str", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_schema_str", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableGetSchemaStrWithIds struct {
	handler ClientService
}

func (p *clientServiceProcessorTableGetSchemaStrWithIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableGetSchemaStrWithIdsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_get_schema_str_with_ids", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableGetSchemaStrWithIdsResult()
	if result.Success, result.E, err = p.handler.TableGetSchemaStrWithIds(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_get_schema_str_with_ids: "+err.Error())
		oprot.WriteMessageBegin("table_get_schema_str_with_ids", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_get_schema_str_with_ids", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetSchemaStrWithIds struct {
	handler ClientService
}

func (p *clientServiceProcessorGetSchemaStrWithIds) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetSchemaStrWithIdsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_schema_str_with_ids", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetSchemaStrWithIdsResult()
	if result.Success, result.E, err = p.handler.GetSchemaStrWithIds(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_schema_str_with_ids: "+err.Error())
		oprot.WriteMessageBegin("get_schema_str_with_ids", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_schema_str_with_ids", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableGetSchema struct {
	handler ClientService
}

func (p *clientServiceProcessorTableGetSchema) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableGetSchemaArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_get_schema", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableGetSchemaResult()
	if result.Success, result.E, err = p.handler.TableGetSchema(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_get_schema: "+err.Error())
		oprot.WriteMessageBegin("table_get_schema", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_get_schema", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetSchema struct {
	handler ClientService
}

func (p *clientServiceProcessorGetSchema) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetSchemaArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_schema", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetSchemaResult()
	if result.Success, result.E, err = p.handler.GetSchema(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_schema: "+err.Error())
		oprot.WriteMessageBegin("get_schema", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_schema", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetTables struct {
	handler ClientService
}

func (p *clientServiceProcessorGetTables) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTablesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_tables", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetTablesResult()
	if result.Success, result.E, err = p.handler.GetTables(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_tables: "+err.Error())
		oprot.WriteMessageBegin("get_tables", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_tables", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNamespaceGetListing struct {
	handler ClientService
}

func (p *clientServiceProcessorNamespaceGetListing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNamespaceGetListingArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("namespace_get_listing", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNamespaceGetListingResult()
	if result.Success, result.E, err = p.handler.NamespaceGetListing(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing namespace_get_listing: "+err.Error())
		oprot.WriteMessageBegin("namespace_get_listing", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("namespace_get_listing", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetListing struct {
	handler ClientService
}

func (p *clientServiceProcessorGetListing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetListingArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_listing", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetListingResult()
	if result.Success, result.E, err = p.handler.GetListing(args.Ns); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_listing: "+err.Error())
		oprot.WriteMessageBegin("get_listing", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_listing", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableGetSplits struct {
	handler ClientService
}

func (p *clientServiceProcessorTableGetSplits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableGetSplitsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_get_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableGetSplitsResult()
	if result.Success, result.E, err = p.handler.TableGetSplits(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_get_splits: "+err.Error())
		oprot.WriteMessageBegin("table_get_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_get_splits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGetTableSplits struct {
	handler ClientService
}

func (p *clientServiceProcessorGetTableSplits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetTableSplitsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_table_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetTableSplitsResult()
	if result.Success, result.E, err = p.handler.GetTableSplits(args.Ns, args.TableName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_table_splits: "+err.Error())
		oprot.WriteMessageBegin("get_table_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_table_splits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorNamespaceDrop struct {
	handler ClientService
}

func (p *clientServiceProcessorNamespaceDrop) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewNamespaceDropArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("namespace_drop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewNamespaceDropResult()
	if result.E, err = p.handler.NamespaceDrop(args.Ns, args.IfExists); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing namespace_drop: "+err.Error())
		oprot.WriteMessageBegin("namespace_drop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("namespace_drop", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorDropNamespace struct {
	handler ClientService
}

func (p *clientServiceProcessorDropNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDropNamespaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("drop_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDropNamespaceResult()
	if result.E, err = p.handler.DropNamespace(args.Ns, args.IfExists); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing drop_namespace: "+err.Error())
		oprot.WriteMessageBegin("drop_namespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("drop_namespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorRenameTable struct {
	handler ClientService
}

func (p *clientServiceProcessorRenameTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRenameTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("rename_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRenameTableResult()
	if result.E, err = p.handler.RenameTable(args.Ns, args.Name, args.NewName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing rename_table: "+err.Error())
		oprot.WriteMessageBegin("rename_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("rename_table", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableRename struct {
	handler ClientService
}

func (p *clientServiceProcessorTableRename) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableRenameArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_rename", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableRenameResult()
	if result.E, err = p.handler.TableRename(args.Ns, args.Name, args.NewName); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_rename: "+err.Error())
		oprot.WriteMessageBegin("table_rename", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_rename", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorDropTable struct {
	handler ClientService
}

func (p *clientServiceProcessorDropTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDropTableArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("drop_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDropTableResult()
	if result.E, err = p.handler.DropTable(args.Ns, args.Name, args.IfExists); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing drop_table: "+err.Error())
		oprot.WriteMessageBegin("drop_table", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("drop_table", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorTableDrop struct {
	handler ClientService
}

func (p *clientServiceProcessorTableDrop) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTableDropArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("table_drop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTableDropResult()
	if result.E, err = p.handler.TableDrop(args.Ns, args.Name, args.IfExists); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing table_drop: "+err.Error())
		oprot.WriteMessageBegin("table_drop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("table_drop", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorGenerateGuid struct {
	handler ClientService
}

func (p *clientServiceProcessorGenerateGuid) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGenerateGuidArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("generate_guid", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGenerateGuidResult()
	if result.Success, err = p.handler.GenerateGuid(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing generate_guid: "+err.Error())
		oprot.WriteMessageBegin("generate_guid", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("generate_guid", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorCreateCellUnique struct {
	handler ClientService
}

func (p *clientServiceProcessorCreateCellUnique) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCreateCellUniqueArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("create_cell_unique", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCreateCellUniqueResult()
	if result.Success, result.E, err = p.handler.CreateCellUnique(args.Ns, args.TableName, args.Key, args.Value); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing create_cell_unique: "+err.Error())
		oprot.WriteMessageBegin("create_cell_unique", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("create_cell_unique", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clientServiceProcessorErrorGetText struct {
	handler ClientService
}

func (p *clientServiceProcessorErrorGetText) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewErrorGetTextArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("error_get_text", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewErrorGetTextResult()
	if result.Success, err = p.handler.ErrorGetText(args.ErrorCode); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing error_get_text: "+err.Error())
		oprot.WriteMessageBegin("error_get_text", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("error_get_text", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type NamespaceCreateArgs struct {
	Ns string `thrift:"ns,1"`
}

func NewNamespaceCreateArgs() *NamespaceCreateArgs {
	return &NamespaceCreateArgs{}
}

func (p *NamespaceCreateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceCreateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *NamespaceCreateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_create_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceCreateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *NamespaceCreateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceCreateArgs(%+v)", *p)
}

type NamespaceCreateResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewNamespaceCreateResult() *NamespaceCreateResult {
	return &NamespaceCreateResult{}
}

func (p *NamespaceCreateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceCreateResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NamespaceCreateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_create_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceCreateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceCreateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceCreateResult(%+v)", *p)
}

type CreateNamespaceArgs struct {
	Ns string `thrift:"ns,1"`
}

func NewCreateNamespaceArgs() *CreateNamespaceArgs {
	return &CreateNamespaceArgs{}
}

func (p *CreateNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *CreateNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("create_namespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *CreateNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNamespaceArgs(%+v)", *p)
}

type CreateNamespaceResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCreateNamespaceResult() *CreateNamespaceResult {
	return &CreateNamespaceResult{}
}

func (p *CreateNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CreateNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("create_namespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CreateNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNamespaceResult(%+v)", *p)
}

type CreateTableArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Schema    string    `thrift:"schema,3"`
}

func NewCreateTableArgs() *CreateTableArgs {
	return &CreateTableArgs{}
}

func (p *CreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *CreateTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *CreateTableArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Schema = v
	}
	return nil
}

func (p *CreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("create_table_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("schema", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:schema: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Schema)); err != nil {
		return fmt.Errorf("%T.schema (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:schema: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableArgs(%+v)", *p)
}

type CreateTableResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCreateTableResult() *CreateTableResult {
	return &CreateTableResult{}
}

func (p *CreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("create_table_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableResult(%+v)", *p)
}

type TableCreateArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Schema    string    `thrift:"schema,3"`
}

func NewTableCreateArgs() *TableCreateArgs {
	return &TableCreateArgs{}
}

func (p *TableCreateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableCreateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableCreateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableCreateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Schema = v
	}
	return nil
}

func (p *TableCreateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_create_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableCreateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableCreateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableCreateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("schema", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:schema: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Schema)); err != nil {
		return fmt.Errorf("%T.schema (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:schema: %s", p, err)
	}
	return err
}

func (p *TableCreateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableCreateArgs(%+v)", *p)
}

type TableCreateResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewTableCreateResult() *TableCreateResult {
	return &TableCreateResult{}
}

func (p *TableCreateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableCreateResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableCreateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_create_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableCreateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableCreateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableCreateResult(%+v)", *p)
}

type AlterTableArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Schema    string    `thrift:"schema,3"`
}

func NewAlterTableArgs() *AlterTableArgs {
	return &AlterTableArgs{}
}

func (p *AlterTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AlterTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *AlterTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *AlterTableArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Schema = v
	}
	return nil
}

func (p *AlterTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("alter_table_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AlterTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *AlterTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *AlterTableArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("schema", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:schema: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Schema)); err != nil {
		return fmt.Errorf("%T.schema (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:schema: %s", p, err)
	}
	return err
}

func (p *AlterTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AlterTableArgs(%+v)", *p)
}

type AlterTableResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAlterTableResult() *AlterTableResult {
	return &AlterTableResult{}
}

func (p *AlterTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AlterTableResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AlterTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("alter_table_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AlterTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AlterTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AlterTableResult(%+v)", *p)
}

type TableAlterArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Schema    string    `thrift:"schema,3"`
}

func NewTableAlterArgs() *TableAlterArgs {
	return &TableAlterArgs{}
}

func (p *TableAlterArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableAlterArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableAlterArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableAlterArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Schema = v
	}
	return nil
}

func (p *TableAlterArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_alter_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableAlterArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableAlterArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableAlterArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("schema", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:schema: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Schema)); err != nil {
		return fmt.Errorf("%T.schema (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:schema: %s", p, err)
	}
	return err
}

func (p *TableAlterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableAlterArgs(%+v)", *p)
}

type TableAlterResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewTableAlterResult() *TableAlterResult {
	return &TableAlterResult{}
}

func (p *TableAlterResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableAlterResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableAlterResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_alter_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableAlterResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableAlterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableAlterResult(%+v)", *p)
}

type RefreshTableArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewRefreshTableArgs() *RefreshTableArgs {
	return &RefreshTableArgs{}
}

func (p *RefreshTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RefreshTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *RefreshTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *RefreshTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refresh_table_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RefreshTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *RefreshTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *RefreshTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RefreshTableArgs(%+v)", *p)
}

type RefreshTableResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewRefreshTableResult() *RefreshTableResult {
	return &RefreshTableResult{}
}

func (p *RefreshTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RefreshTableResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *RefreshTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refresh_table_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RefreshTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *RefreshTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RefreshTableResult(%+v)", *p)
}

type NamespaceOpenArgs struct {
	Ns string `thrift:"ns,1"`
}

func NewNamespaceOpenArgs() *NamespaceOpenArgs {
	return &NamespaceOpenArgs{}
}

func (p *NamespaceOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *NamespaceOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_open_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *NamespaceOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceOpenArgs(%+v)", *p)
}

type NamespaceOpenResult struct {
	Success Namespace        `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNamespaceOpenResult() *NamespaceOpenResult {
	return &NamespaceOpenResult{}
}

func (p *NamespaceOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Namespace(v)
	}
	return nil
}

func (p *NamespaceOpenResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NamespaceOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_open_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *NamespaceOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceOpenResult(%+v)", *p)
}

type OpenNamespaceArgs struct {
	Ns string `thrift:"ns,1"`
}

func NewOpenNamespaceArgs() *OpenNamespaceArgs {
	return &OpenNamespaceArgs{}
}

func (p *OpenNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *OpenNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_namespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OpenNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenNamespaceArgs(%+v)", *p)
}

type OpenNamespaceResult struct {
	Success Namespace        `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewOpenNamespaceResult() *OpenNamespaceResult {
	return &OpenNamespaceResult{}
}

func (p *OpenNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenNamespaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Namespace(v)
	}
	return nil
}

func (p *OpenNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OpenNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_namespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenNamespaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OpenNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenNamespaceResult(%+v)", *p)
}

type NamespaceCloseArgs struct {
	Ns Namespace `thrift:"ns,1"`
}

func NewNamespaceCloseArgs() *NamespaceCloseArgs {
	return &NamespaceCloseArgs{}
}

func (p *NamespaceCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *NamespaceCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *NamespaceCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceCloseArgs(%+v)", *p)
}

type NamespaceCloseResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewNamespaceCloseResult() *NamespaceCloseResult {
	return &NamespaceCloseResult{}
}

func (p *NamespaceCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceCloseResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NamespaceCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceCloseResult(%+v)", *p)
}

type CloseNamespaceArgs struct {
	Ns Namespace `thrift:"ns,1"`
}

func NewCloseNamespaceArgs() *CloseNamespaceArgs {
	return &CloseNamespaceArgs{}
}

func (p *CloseNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *CloseNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_namespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *CloseNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseNamespaceArgs(%+v)", *p)
}

type CloseNamespaceResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCloseNamespaceResult() *CloseNamespaceResult {
	return &CloseNamespaceResult{}
}

func (p *CloseNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CloseNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_namespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CloseNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseNamespaceResult(%+v)", *p)
}

type FutureOpenArgs struct {
	Capacity int32 `thrift:"capacity,1"`
}

func NewFutureOpenArgs() *FutureOpenArgs {
	return &FutureOpenArgs{
		Capacity: 0,
	}
}

func (p *FutureOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Capacity = v
	}
	return nil
}

func (p *FutureOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_open_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("capacity", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:capacity: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Capacity)); err != nil {
		return fmt.Errorf("%T.capacity (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:capacity: %s", p, err)
	}
	return err
}

func (p *FutureOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureOpenArgs(%+v)", *p)
}

type FutureOpenResult struct {
	Success Future           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureOpenResult() *FutureOpenResult {
	return &FutureOpenResult{}
}

func (p *FutureOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Future(v)
	}
	return nil
}

func (p *FutureOpenResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_open_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *FutureOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureOpenResult(%+v)", *p)
}

type OpenFutureArgs struct {
	Capacity int32 `thrift:"capacity,1"`
}

func NewOpenFutureArgs() *OpenFutureArgs {
	return &OpenFutureArgs{
		Capacity: 0,
	}
}

func (p *OpenFutureArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenFutureArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Capacity = v
	}
	return nil
}

func (p *OpenFutureArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_future_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenFutureArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("capacity", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:capacity: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Capacity)); err != nil {
		return fmt.Errorf("%T.capacity (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:capacity: %s", p, err)
	}
	return err
}

func (p *OpenFutureArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenFutureArgs(%+v)", *p)
}

type OpenFutureResult struct {
	Success Future           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewOpenFutureResult() *OpenFutureResult {
	return &OpenFutureResult{}
}

func (p *OpenFutureResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenFutureResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Future(v)
	}
	return nil
}

func (p *OpenFutureResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OpenFutureResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_future_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenFutureResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenFutureResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OpenFutureResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenFutureResult(%+v)", *p)
}

type FutureCancelArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewFutureCancelArgs() *FutureCancelArgs {
	return &FutureCancelArgs{}
}

func (p *FutureCancelArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureCancelArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureCancelArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_cancel_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureCancelArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureCancelArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureCancelArgs(%+v)", *p)
}

type FutureCancelResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewFutureCancelResult() *FutureCancelResult {
	return &FutureCancelResult{}
}

func (p *FutureCancelResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureCancelResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureCancelResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_cancel_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureCancelResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureCancelResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureCancelResult(%+v)", *p)
}

type CancelFutureArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewCancelFutureArgs() *CancelFutureArgs {
	return &CancelFutureArgs{}
}

func (p *CancelFutureArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelFutureArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *CancelFutureArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancel_future_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelFutureArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *CancelFutureArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelFutureArgs(%+v)", *p)
}

type CancelFutureResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCancelFutureResult() *CancelFutureResult {
	return &CancelFutureResult{}
}

func (p *CancelFutureResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelFutureResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CancelFutureResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancel_future_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelFutureResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CancelFutureResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelFutureResult(%+v)", *p)
}

type FutureGetResultArgs struct {
	Ff            Future `thrift:"ff,1"`
	TimeoutMillis int32  `thrift:"timeout_millis,2"`
}

func NewFutureGetResultArgs() *FutureGetResultArgs {
	return &FutureGetResultArgs{
		TimeoutMillis: 0,
	}
}

func (p *FutureGetResultArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureGetResultArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureGetResultArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TimeoutMillis = v
	}
	return nil
}

func (p *FutureGetResultArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_get_result_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureGetResultArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureGetResultArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timeout_millis", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:timeout_millis: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TimeoutMillis)); err != nil {
		return fmt.Errorf("%T.timeout_millis (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:timeout_millis: %s", p, err)
	}
	return err
}

func (p *FutureGetResultArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureGetResultArgs(%+v)", *p)
}

type FutureGetResultResult struct {
	Success *Result          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureGetResultResult() *FutureGetResultResult {
	return &FutureGetResultResult{}
}

func (p *FutureGetResultResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureGetResultResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FutureGetResultResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureGetResultResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_get_result_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureGetResultResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FutureGetResultResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureGetResultResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureGetResultResult(%+v)", *p)
}

type GetFutureResultArgs struct {
	Ff            Future `thrift:"ff,1"`
	TimeoutMillis int32  `thrift:"timeout_millis,2"`
}

func NewGetFutureResultArgs() *GetFutureResultArgs {
	return &GetFutureResultArgs{
		TimeoutMillis: 0,
	}
}

func (p *GetFutureResultArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFutureResultArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *GetFutureResultArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TimeoutMillis = v
	}
	return nil
}

func (p *GetFutureResultArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_future_result_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFutureResultArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *GetFutureResultArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timeout_millis", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:timeout_millis: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TimeoutMillis)); err != nil {
		return fmt.Errorf("%T.timeout_millis (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:timeout_millis: %s", p, err)
	}
	return err
}

func (p *GetFutureResultArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFutureResultArgs(%+v)", *p)
}

type GetFutureResultResult struct {
	Success *Result          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetFutureResultResult() *GetFutureResultResult {
	return &GetFutureResultResult{}
}

func (p *GetFutureResultResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFutureResultResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetFutureResultResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetFutureResultResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_future_result_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFutureResultResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetFutureResultResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetFutureResultResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFutureResultResult(%+v)", *p)
}

type FutureGetResultAsArraysArgs struct {
	Ff            Future `thrift:"ff,1"`
	TimeoutMillis int32  `thrift:"timeout_millis,2"`
}

func NewFutureGetResultAsArraysArgs() *FutureGetResultAsArraysArgs {
	return &FutureGetResultAsArraysArgs{
		TimeoutMillis: 0,
	}
}

func (p *FutureGetResultAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureGetResultAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureGetResultAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TimeoutMillis = v
	}
	return nil
}

func (p *FutureGetResultAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_get_result_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureGetResultAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureGetResultAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timeout_millis", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:timeout_millis: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TimeoutMillis)); err != nil {
		return fmt.Errorf("%T.timeout_millis (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:timeout_millis: %s", p, err)
	}
	return err
}

func (p *FutureGetResultAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureGetResultAsArraysArgs(%+v)", *p)
}

type FutureGetResultAsArraysResult struct {
	Success *ResultAsArrays  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureGetResultAsArraysResult() *FutureGetResultAsArraysResult {
	return &FutureGetResultAsArraysResult{}
}

func (p *FutureGetResultAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureGetResultAsArraysResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewResultAsArrays()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FutureGetResultAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureGetResultAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_get_result_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureGetResultAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FutureGetResultAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureGetResultAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureGetResultAsArraysResult(%+v)", *p)
}

type GetFutureResultAsArraysArgs struct {
	Ff            Future `thrift:"ff,1"`
	TimeoutMillis int32  `thrift:"timeout_millis,2"`
}

func NewGetFutureResultAsArraysArgs() *GetFutureResultAsArraysArgs {
	return &GetFutureResultAsArraysArgs{
		TimeoutMillis: 0,
	}
}

func (p *GetFutureResultAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFutureResultAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *GetFutureResultAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TimeoutMillis = v
	}
	return nil
}

func (p *GetFutureResultAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_future_result_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFutureResultAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *GetFutureResultAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timeout_millis", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:timeout_millis: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TimeoutMillis)); err != nil {
		return fmt.Errorf("%T.timeout_millis (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:timeout_millis: %s", p, err)
	}
	return err
}

func (p *GetFutureResultAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFutureResultAsArraysArgs(%+v)", *p)
}

type GetFutureResultAsArraysResult struct {
	Success *ResultAsArrays  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetFutureResultAsArraysResult() *GetFutureResultAsArraysResult {
	return &GetFutureResultAsArraysResult{}
}

func (p *GetFutureResultAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFutureResultAsArraysResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewResultAsArrays()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetFutureResultAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetFutureResultAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_future_result_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFutureResultAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetFutureResultAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetFutureResultAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFutureResultAsArraysResult(%+v)", *p)
}

type FutureGetResultSerializedArgs struct {
	Ff            Future `thrift:"ff,1"`
	TimeoutMillis int32  `thrift:"timeout_millis,2"`
}

func NewFutureGetResultSerializedArgs() *FutureGetResultSerializedArgs {
	return &FutureGetResultSerializedArgs{
		TimeoutMillis: 0,
	}
}

func (p *FutureGetResultSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureGetResultSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureGetResultSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TimeoutMillis = v
	}
	return nil
}

func (p *FutureGetResultSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_get_result_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureGetResultSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureGetResultSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timeout_millis", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:timeout_millis: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TimeoutMillis)); err != nil {
		return fmt.Errorf("%T.timeout_millis (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:timeout_millis: %s", p, err)
	}
	return err
}

func (p *FutureGetResultSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureGetResultSerializedArgs(%+v)", *p)
}

type FutureGetResultSerializedResult struct {
	Success *ResultSerialized `thrift:"success,0"`
	E       *ClientException  `thrift:"e,1"`
}

func NewFutureGetResultSerializedResult() *FutureGetResultSerializedResult {
	return &FutureGetResultSerializedResult{}
}

func (p *FutureGetResultSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureGetResultSerializedResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewResultSerialized()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *FutureGetResultSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureGetResultSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_get_result_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureGetResultSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FutureGetResultSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureGetResultSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureGetResultSerializedResult(%+v)", *p)
}

type GetFutureResultSerializedArgs struct {
	Ff            Future `thrift:"ff,1"`
	TimeoutMillis int32  `thrift:"timeout_millis,2"`
}

func NewGetFutureResultSerializedArgs() *GetFutureResultSerializedArgs {
	return &GetFutureResultSerializedArgs{
		TimeoutMillis: 0,
	}
}

func (p *GetFutureResultSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFutureResultSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *GetFutureResultSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TimeoutMillis = v
	}
	return nil
}

func (p *GetFutureResultSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_future_result_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFutureResultSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *GetFutureResultSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timeout_millis", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:timeout_millis: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TimeoutMillis)); err != nil {
		return fmt.Errorf("%T.timeout_millis (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:timeout_millis: %s", p, err)
	}
	return err
}

func (p *GetFutureResultSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFutureResultSerializedArgs(%+v)", *p)
}

type GetFutureResultSerializedResult struct {
	Success *ResultSerialized `thrift:"success,0"`
	E       *ClientException  `thrift:"e,1"`
}

func NewGetFutureResultSerializedResult() *GetFutureResultSerializedResult {
	return &GetFutureResultSerializedResult{}
}

func (p *GetFutureResultSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetFutureResultSerializedResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewResultSerialized()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetFutureResultSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetFutureResultSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_future_result_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetFutureResultSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetFutureResultSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetFutureResultSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetFutureResultSerializedResult(%+v)", *p)
}

type FutureIsEmptyArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewFutureIsEmptyArgs() *FutureIsEmptyArgs {
	return &FutureIsEmptyArgs{}
}

func (p *FutureIsEmptyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureIsEmptyArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureIsEmptyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_is_empty_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureIsEmptyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureIsEmptyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureIsEmptyArgs(%+v)", *p)
}

type FutureIsEmptyResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureIsEmptyResult() *FutureIsEmptyResult {
	return &FutureIsEmptyResult{}
}

func (p *FutureIsEmptyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureIsEmptyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *FutureIsEmptyResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureIsEmptyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_is_empty_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureIsEmptyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *FutureIsEmptyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureIsEmptyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureIsEmptyResult(%+v)", *p)
}

type FutureIsFullArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewFutureIsFullArgs() *FutureIsFullArgs {
	return &FutureIsFullArgs{}
}

func (p *FutureIsFullArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureIsFullArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureIsFullArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_is_full_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureIsFullArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureIsFullArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureIsFullArgs(%+v)", *p)
}

type FutureIsFullResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureIsFullResult() *FutureIsFullResult {
	return &FutureIsFullResult{}
}

func (p *FutureIsFullResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureIsFullResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *FutureIsFullResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureIsFullResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_is_full_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureIsFullResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *FutureIsFullResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureIsFullResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureIsFullResult(%+v)", *p)
}

type FutureIsCancelledArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewFutureIsCancelledArgs() *FutureIsCancelledArgs {
	return &FutureIsCancelledArgs{}
}

func (p *FutureIsCancelledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureIsCancelledArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureIsCancelledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_is_cancelled_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureIsCancelledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureIsCancelledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureIsCancelledArgs(%+v)", *p)
}

type FutureIsCancelledResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureIsCancelledResult() *FutureIsCancelledResult {
	return &FutureIsCancelledResult{}
}

func (p *FutureIsCancelledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureIsCancelledResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *FutureIsCancelledResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureIsCancelledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_is_cancelled_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureIsCancelledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *FutureIsCancelledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureIsCancelledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureIsCancelledResult(%+v)", *p)
}

type FutureHasOutstandingArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewFutureHasOutstandingArgs() *FutureHasOutstandingArgs {
	return &FutureHasOutstandingArgs{}
}

func (p *FutureHasOutstandingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureHasOutstandingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureHasOutstandingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_has_outstanding_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureHasOutstandingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureHasOutstandingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureHasOutstandingArgs(%+v)", *p)
}

type FutureHasOutstandingResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewFutureHasOutstandingResult() *FutureHasOutstandingResult {
	return &FutureHasOutstandingResult{}
}

func (p *FutureHasOutstandingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureHasOutstandingResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *FutureHasOutstandingResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureHasOutstandingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_has_outstanding_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureHasOutstandingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *FutureHasOutstandingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureHasOutstandingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureHasOutstandingResult(%+v)", *p)
}

type FutureCloseArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewFutureCloseArgs() *FutureCloseArgs {
	return &FutureCloseArgs{}
}

func (p *FutureCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *FutureCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *FutureCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureCloseArgs(%+v)", *p)
}

type FutureCloseResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewFutureCloseResult() *FutureCloseResult {
	return &FutureCloseResult{}
}

func (p *FutureCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FutureCloseResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FutureCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("future_close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FutureCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FutureCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FutureCloseResult(%+v)", *p)
}

type CloseFutureArgs struct {
	Ff Future `thrift:"ff,1"`
}

func NewCloseFutureArgs() *CloseFutureArgs {
	return &CloseFutureArgs{}
}

func (p *CloseFutureArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseFutureArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ff = Future(v)
	}
	return nil
}

func (p *CloseFutureArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_future_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseFutureArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ff", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ff: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ff)); err != nil {
		return fmt.Errorf("%T.ff (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ff: %s", p, err)
	}
	return err
}

func (p *CloseFutureArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseFutureArgs(%+v)", *p)
}

type CloseFutureResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCloseFutureResult() *CloseFutureResult {
	return &CloseFutureResult{}
}

func (p *CloseFutureResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseFutureResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CloseFutureResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_future_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseFutureResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CloseFutureResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseFutureResult(%+v)", *p)
}

type ScannerOpenArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	ScanSpec  *ScanSpec `thrift:"scan_spec,3"`
}

func NewScannerOpenArgs() *ScannerOpenArgs {
	return &ScannerOpenArgs{}
}

func (p *ScannerOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *ScannerOpenArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *ScannerOpenArgs) readField3(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *ScannerOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_open_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *ScannerOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *ScannerOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenArgs(%+v)", *p)
}

type ScannerOpenResult struct {
	Success Scanner          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerOpenResult() *ScannerOpenResult {
	return &ScannerOpenResult{}
}

func (p *ScannerOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Scanner(v)
	}
	return nil
}

func (p *ScannerOpenResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_open_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ScannerOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenResult(%+v)", *p)
}

type OpenScannerArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	ScanSpec  *ScanSpec `thrift:"scan_spec,3"`
}

func NewOpenScannerArgs() *OpenScannerArgs {
	return &OpenScannerArgs{}
}

func (p *OpenScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OpenScannerArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OpenScannerArgs) readField3(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *OpenScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_scanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OpenScannerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OpenScannerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerArgs(%+v)", *p)
}

type OpenScannerResult struct {
	Success Scanner          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewOpenScannerResult() *OpenScannerResult {
	return &OpenScannerResult{}
}

func (p *OpenScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Scanner(v)
	}
	return nil
}

func (p *OpenScannerResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OpenScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_scanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerResult(%+v)", *p)
}

type AsyncScannerOpenArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Future    Future    `thrift:"future,3"`
	ScanSpec  *ScanSpec `thrift:"scan_spec,4"`
}

func NewAsyncScannerOpenArgs() *AsyncScannerOpenArgs {
	return &AsyncScannerOpenArgs{}
}

func (p *AsyncScannerOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncScannerOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *AsyncScannerOpenArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *AsyncScannerOpenArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Future = Future(v)
	}
	return nil
}

func (p *AsyncScannerOpenArgs) readField4(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *AsyncScannerOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_scanner_open_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncScannerOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *AsyncScannerOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *AsyncScannerOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("future", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:future: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Future)); err != nil {
		return fmt.Errorf("%T.future (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:future: %s", p, err)
	}
	return err
}

func (p *AsyncScannerOpenArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *AsyncScannerOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncScannerOpenArgs(%+v)", *p)
}

type AsyncScannerOpenResult struct {
	Success ScannerAsync     `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewAsyncScannerOpenResult() *AsyncScannerOpenResult {
	return &AsyncScannerOpenResult{}
}

func (p *AsyncScannerOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncScannerOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerAsync(v)
	}
	return nil
}

func (p *AsyncScannerOpenResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncScannerOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_scanner_open_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncScannerOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *AsyncScannerOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncScannerOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncScannerOpenResult(%+v)", *p)
}

type OpenScannerAsyncArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Future    Future    `thrift:"future,3"`
	ScanSpec  *ScanSpec `thrift:"scan_spec,4"`
}

func NewOpenScannerAsyncArgs() *OpenScannerAsyncArgs {
	return &OpenScannerAsyncArgs{}
}

func (p *OpenScannerAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OpenScannerAsyncArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OpenScannerAsyncArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Future = Future(v)
	}
	return nil
}

func (p *OpenScannerAsyncArgs) readField4(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *OpenScannerAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_scanner_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OpenScannerAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OpenScannerAsyncArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("future", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:future: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Future)); err != nil {
		return fmt.Errorf("%T.future (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:future: %s", p, err)
	}
	return err
}

func (p *OpenScannerAsyncArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerAsyncArgs(%+v)", *p)
}

type OpenScannerAsyncResult struct {
	Success ScannerAsync     `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewOpenScannerAsyncResult() *OpenScannerAsyncResult {
	return &OpenScannerAsyncResult{}
}

func (p *OpenScannerAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerAsyncResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = ScannerAsync(v)
	}
	return nil
}

func (p *OpenScannerAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OpenScannerAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_scanner_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerAsyncResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenScannerAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerAsyncResult(%+v)", *p)
}

type ScannerCloseArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerCloseArgs() *ScannerCloseArgs {
	return &ScannerCloseArgs{}
}

func (p *ScannerCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseArgs(%+v)", *p)
}

type ScannerCloseResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewScannerCloseResult() *ScannerCloseResult {
	return &ScannerCloseResult{}
}

func (p *ScannerCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseResult(%+v)", *p)
}

type CloseScannerArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewCloseScannerArgs() *CloseScannerArgs {
	return &CloseScannerArgs{}
}

func (p *CloseScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *CloseScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_scanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *CloseScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerArgs(%+v)", *p)
}

type CloseScannerResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCloseScannerResult() *CloseScannerResult {
	return &CloseScannerResult{}
}

func (p *CloseScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CloseScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_scanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerResult(%+v)", *p)
}

type AsyncScannerCancelArgs struct {
	Scanner ScannerAsync `thrift:"scanner,1"`
}

func NewAsyncScannerCancelArgs() *AsyncScannerCancelArgs {
	return &AsyncScannerCancelArgs{}
}

func (p *AsyncScannerCancelArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncScannerCancelArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = ScannerAsync(v)
	}
	return nil
}

func (p *AsyncScannerCancelArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_scanner_cancel_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncScannerCancelArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *AsyncScannerCancelArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncScannerCancelArgs(%+v)", *p)
}

type AsyncScannerCancelResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncScannerCancelResult() *AsyncScannerCancelResult {
	return &AsyncScannerCancelResult{}
}

func (p *AsyncScannerCancelResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncScannerCancelResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncScannerCancelResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_scanner_cancel_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncScannerCancelResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncScannerCancelResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncScannerCancelResult(%+v)", *p)
}

type CancelScannerAsyncArgs struct {
	Scanner ScannerAsync `thrift:"scanner,1"`
}

func NewCancelScannerAsyncArgs() *CancelScannerAsyncArgs {
	return &CancelScannerAsyncArgs{}
}

func (p *CancelScannerAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelScannerAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = ScannerAsync(v)
	}
	return nil
}

func (p *CancelScannerAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancel_scanner_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelScannerAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *CancelScannerAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelScannerAsyncArgs(%+v)", *p)
}

type CancelScannerAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCancelScannerAsyncResult() *CancelScannerAsyncResult {
	return &CancelScannerAsyncResult{}
}

func (p *CancelScannerAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelScannerAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CancelScannerAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancel_scanner_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelScannerAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CancelScannerAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelScannerAsyncResult(%+v)", *p)
}

type AsyncScannerCloseArgs struct {
	Scanner ScannerAsync `thrift:"scanner,1"`
}

func NewAsyncScannerCloseArgs() *AsyncScannerCloseArgs {
	return &AsyncScannerCloseArgs{}
}

func (p *AsyncScannerCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncScannerCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = ScannerAsync(v)
	}
	return nil
}

func (p *AsyncScannerCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_scanner_close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncScannerCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *AsyncScannerCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncScannerCloseArgs(%+v)", *p)
}

type AsyncScannerCloseResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncScannerCloseResult() *AsyncScannerCloseResult {
	return &AsyncScannerCloseResult{}
}

func (p *AsyncScannerCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncScannerCloseResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncScannerCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_scanner_close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncScannerCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncScannerCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncScannerCloseResult(%+v)", *p)
}

type CloseScannerAsyncArgs struct {
	Scanner ScannerAsync `thrift:"scanner,1"`
}

func NewCloseScannerAsyncArgs() *CloseScannerAsyncArgs {
	return &CloseScannerAsyncArgs{}
}

func (p *CloseScannerAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = ScannerAsync(v)
	}
	return nil
}

func (p *CloseScannerAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_scanner_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *CloseScannerAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerAsyncArgs(%+v)", *p)
}

type CloseScannerAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCloseScannerAsyncResult() *CloseScannerAsyncResult {
	return &CloseScannerAsyncResult{}
}

func (p *CloseScannerAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CloseScannerAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_scanner_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerAsyncResult(%+v)", *p)
}

type ScannerGetCellsArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerGetCellsArgs() *ScannerGetCellsArgs {
	return &ScannerGetCellsArgs{}
}

func (p *ScannerGetCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerGetCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerGetCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetCellsArgs(%+v)", *p)
}

type ScannerGetCellsResult struct {
	Success []*Cell          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerGetCellsResult() *ScannerGetCellsResult {
	return &ScannerGetCellsResult{}
}

func (p *ScannerGetCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetCellsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem518 := NewCell()
		if err := _elem518.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem518)
		}
		p.Success = append(p.Success, _elem518)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerGetCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerGetCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetCellsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetCellsResult(%+v)", *p)
}

type NextCellsArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewNextCellsArgs() *NextCellsArgs {
	return &NextCellsArgs{}
}

func (p *NextCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *NextCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *NextCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextCellsArgs(%+v)", *p)
}

type NextCellsResult struct {
	Success []*Cell          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNextCellsResult() *NextCellsResult {
	return &NextCellsResult{}
}

func (p *NextCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextCellsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem519 := NewCell()
		if err := _elem519.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem519)
		}
		p.Success = append(p.Success, _elem519)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *NextCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NextCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextCellsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NextCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NextCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextCellsResult(%+v)", *p)
}

type ScannerGetCellsAsArraysArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerGetCellsAsArraysArgs() *ScannerGetCellsAsArraysArgs {
	return &ScannerGetCellsAsArraysArgs{}
}

func (p *ScannerGetCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerGetCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerGetCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetCellsAsArraysArgs(%+v)", *p)
}

type ScannerGetCellsAsArraysResult struct {
	Success []CellAsArray    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerGetCellsAsArraysResult() *ScannerGetCellsAsArraysResult {
	return &ScannerGetCellsAsArraysResult{}
}

func (p *ScannerGetCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetCellsAsArraysResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem520 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem521 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem521 = v
			}
			_elem520 = append(_elem520, _elem521)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success = append(p.Success, _elem520)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerGetCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerGetCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetCellsAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetCellsAsArraysResult(%+v)", *p)
}

type NextCellsAsArraysArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewNextCellsAsArraysArgs() *NextCellsAsArraysArgs {
	return &NextCellsAsArraysArgs{}
}

func (p *NextCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *NextCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *NextCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextCellsAsArraysArgs(%+v)", *p)
}

type NextCellsAsArraysResult struct {
	Success []CellAsArray    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNextCellsAsArraysResult() *NextCellsAsArraysResult {
	return &NextCellsAsArraysResult{}
}

func (p *NextCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextCellsAsArraysResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem522 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem523 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem523 = v
			}
			_elem522 = append(_elem522, _elem523)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success = append(p.Success, _elem522)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *NextCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NextCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextCellsAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NextCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NextCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextCellsAsArraysResult(%+v)", *p)
}

type ScannerGetCellsSerializedArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerGetCellsSerializedArgs() *ScannerGetCellsSerializedArgs {
	return &ScannerGetCellsSerializedArgs{}
}

func (p *ScannerGetCellsSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetCellsSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerGetCellsSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_cells_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetCellsSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerGetCellsSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetCellsSerializedArgs(%+v)", *p)
}

type ScannerGetCellsSerializedResult struct {
	Success CellsSerialized  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerGetCellsSerializedResult() *ScannerGetCellsSerializedResult {
	return &ScannerGetCellsSerializedResult{}
}

func (p *ScannerGetCellsSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetCellsSerializedResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = CellsSerialized(v)
	}
	return nil
}

func (p *ScannerGetCellsSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerGetCellsSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_cells_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetCellsSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetCellsSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetCellsSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetCellsSerializedResult(%+v)", *p)
}

type NextCellsSerializedArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewNextCellsSerializedArgs() *NextCellsSerializedArgs {
	return &NextCellsSerializedArgs{}
}

func (p *NextCellsSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextCellsSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *NextCellsSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_cells_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextCellsSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *NextCellsSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextCellsSerializedArgs(%+v)", *p)
}

type NextCellsSerializedResult struct {
	Success CellsSerialized  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNextCellsSerializedResult() *NextCellsSerializedResult {
	return &NextCellsSerializedResult{}
}

func (p *NextCellsSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextCellsSerializedResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = CellsSerialized(v)
	}
	return nil
}

func (p *NextCellsSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NextCellsSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_cells_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextCellsSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NextCellsSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NextCellsSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextCellsSerializedResult(%+v)", *p)
}

type ScannerGetRowArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerGetRowArgs() *ScannerGetRowArgs {
	return &ScannerGetRowArgs{}
}

func (p *ScannerGetRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerGetRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_row_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerGetRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetRowArgs(%+v)", *p)
}

type ScannerGetRowResult struct {
	Success []*Cell          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerGetRowResult() *ScannerGetRowResult {
	return &ScannerGetRowResult{}
}

func (p *ScannerGetRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetRowResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem524 := NewCell()
		if err := _elem524.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem524)
		}
		p.Success = append(p.Success, _elem524)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerGetRowResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerGetRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_row_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetRowResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetRowResult(%+v)", *p)
}

type NextRowArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewNextRowArgs() *NextRowArgs {
	return &NextRowArgs{}
}

func (p *NextRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *NextRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_row_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *NextRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextRowArgs(%+v)", *p)
}

type NextRowResult struct {
	Success []*Cell          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNextRowResult() *NextRowResult {
	return &NextRowResult{}
}

func (p *NextRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextRowResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem525 := NewCell()
		if err := _elem525.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem525)
		}
		p.Success = append(p.Success, _elem525)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *NextRowResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NextRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_row_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextRowResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NextRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NextRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextRowResult(%+v)", *p)
}

type ScannerGetRowAsArraysArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerGetRowAsArraysArgs() *ScannerGetRowAsArraysArgs {
	return &ScannerGetRowAsArraysArgs{}
}

func (p *ScannerGetRowAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetRowAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerGetRowAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_row_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetRowAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerGetRowAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetRowAsArraysArgs(%+v)", *p)
}

type ScannerGetRowAsArraysResult struct {
	Success []CellAsArray    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerGetRowAsArraysResult() *ScannerGetRowAsArraysResult {
	return &ScannerGetRowAsArraysResult{}
}

func (p *ScannerGetRowAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetRowAsArraysResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem526 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem527 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem527 = v
			}
			_elem526 = append(_elem526, _elem527)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success = append(p.Success, _elem526)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ScannerGetRowAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerGetRowAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_row_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetRowAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetRowAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetRowAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetRowAsArraysResult(%+v)", *p)
}

type NextRowAsArraysArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewNextRowAsArraysArgs() *NextRowAsArraysArgs {
	return &NextRowAsArraysArgs{}
}

func (p *NextRowAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextRowAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *NextRowAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_row_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextRowAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *NextRowAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextRowAsArraysArgs(%+v)", *p)
}

type NextRowAsArraysResult struct {
	Success []CellAsArray    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNextRowAsArraysResult() *NextRowAsArraysResult {
	return &NextRowAsArraysResult{}
}

func (p *NextRowAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextRowAsArraysResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem528 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem529 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem529 = v
			}
			_elem528 = append(_elem528, _elem529)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success = append(p.Success, _elem528)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *NextRowAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NextRowAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_row_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextRowAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NextRowAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NextRowAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextRowAsArraysResult(%+v)", *p)
}

type ScannerGetRowSerializedArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewScannerGetRowSerializedArgs() *ScannerGetRowSerializedArgs {
	return &ScannerGetRowSerializedArgs{}
}

func (p *ScannerGetRowSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetRowSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *ScannerGetRowSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_row_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetRowSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *ScannerGetRowSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetRowSerializedArgs(%+v)", *p)
}

type ScannerGetRowSerializedResult struct {
	Success CellsSerialized  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewScannerGetRowSerializedResult() *ScannerGetRowSerializedResult {
	return &ScannerGetRowSerializedResult{}
}

func (p *ScannerGetRowSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetRowSerializedResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = CellsSerialized(v)
	}
	return nil
}

func (p *ScannerGetRowSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ScannerGetRowSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scanner_get_row_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetRowSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetRowSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetRowSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetRowSerializedResult(%+v)", *p)
}

type NextRowSerializedArgs struct {
	Scanner Scanner `thrift:"scanner,1"`
}

func NewNextRowSerializedArgs() *NextRowSerializedArgs {
	return &NextRowSerializedArgs{}
}

func (p *NextRowSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextRowSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Scanner = Scanner(v)
	}
	return nil
}

func (p *NextRowSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_row_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextRowSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scanner", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scanner: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Scanner)); err != nil {
		return fmt.Errorf("%T.scanner (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scanner: %s", p, err)
	}
	return err
}

func (p *NextRowSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextRowSerializedArgs(%+v)", *p)
}

type NextRowSerializedResult struct {
	Success CellsSerialized  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNextRowSerializedResult() *NextRowSerializedResult {
	return &NextRowSerializedResult{}
}

func (p *NextRowSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NextRowSerializedResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = CellsSerialized(v)
	}
	return nil
}

func (p *NextRowSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NextRowSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("next_row_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NextRowSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NextRowSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NextRowSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NextRowSerializedResult(%+v)", *p)
}

type GetRowArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Row       string    `thrift:"row,3"`
}

func NewGetRowArgs() *GetRowArgs {
	return &GetRowArgs{}
}

func (p *GetRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetRowArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetRowArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Row = v
	}
	return nil
}

func (p *GetRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_row_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:row: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Row)); err != nil {
		return fmt.Errorf("%T.row (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:row: %s", p, err)
	}
	return err
}

func (p *GetRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowArgs(%+v)", *p)
}

type GetRowResult struct {
	Success []*Cell          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetRowResult() *GetRowResult {
	return &GetRowResult{}
}

func (p *GetRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem530 := NewCell()
		if err := _elem530.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem530)
		}
		p.Success = append(p.Success, _elem530)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_row_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowResult(%+v)", *p)
}

type GetRowAsArraysArgs struct {
	Ns   Namespace `thrift:"ns,1"`
	Name string    `thrift:"name,2"`
	Row  string    `thrift:"row,3"`
}

func NewGetRowAsArraysArgs() *GetRowAsArraysArgs {
	return &GetRowAsArraysArgs{}
}

func (p *GetRowAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetRowAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *GetRowAsArraysArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Row = v
	}
	return nil
}

func (p *GetRowAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_row_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetRowAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *GetRowAsArraysArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:row: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Row)); err != nil {
		return fmt.Errorf("%T.row (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:row: %s", p, err)
	}
	return err
}

func (p *GetRowAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowAsArraysArgs(%+v)", *p)
}

type GetRowAsArraysResult struct {
	Success []CellAsArray    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetRowAsArraysResult() *GetRowAsArraysResult {
	return &GetRowAsArraysResult{}
}

func (p *GetRowAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowAsArraysResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem531 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem532 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem532 = v
			}
			_elem531 = append(_elem531, _elem532)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success = append(p.Success, _elem531)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRowAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetRowAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_row_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetRowAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowAsArraysResult(%+v)", *p)
}

type GetRowSerializedArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Row       string    `thrift:"row,3"`
}

func NewGetRowSerializedArgs() *GetRowSerializedArgs {
	return &GetRowSerializedArgs{}
}

func (p *GetRowSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetRowSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetRowSerializedArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Row = v
	}
	return nil
}

func (p *GetRowSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_row_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetRowSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetRowSerializedArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:row: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Row)); err != nil {
		return fmt.Errorf("%T.row (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:row: %s", p, err)
	}
	return err
}

func (p *GetRowSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowSerializedArgs(%+v)", *p)
}

type GetRowSerializedResult struct {
	Success CellsSerialized  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetRowSerializedResult() *GetRowSerializedResult {
	return &GetRowSerializedResult{}
}

func (p *GetRowSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowSerializedResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = CellsSerialized(v)
	}
	return nil
}

func (p *GetRowSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetRowSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_row_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetRowSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowSerializedResult(%+v)", *p)
}

type GetCellArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Row       string    `thrift:"row,3"`
	Column    string    `thrift:"column,4"`
}

func NewGetCellArgs() *GetCellArgs {
	return &GetCellArgs{}
}

func (p *GetCellArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetCellArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetCellArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Row = v
	}
	return nil
}

func (p *GetCellArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Column = v
	}
	return nil
}

func (p *GetCellArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cell_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetCellArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetCellArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:row: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Row)); err != nil {
		return fmt.Errorf("%T.row (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:row: %s", p, err)
	}
	return err
}

func (p *GetCellArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:column: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Column)); err != nil {
		return fmt.Errorf("%T.column (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:column: %s", p, err)
	}
	return err
}

func (p *GetCellArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellArgs(%+v)", *p)
}

type GetCellResult struct {
	Success Value            `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetCellResult() *GetCellResult {
	return &GetCellResult{}
}

func (p *GetCellResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Value(v)
	}
	return nil
}

func (p *GetCellResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetCellResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cell_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetCellResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetCellResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellResult(%+v)", *p)
}

type GetCellsArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	ScanSpec  *ScanSpec `thrift:"scan_spec,3"`
}

func NewGetCellsArgs() *GetCellsArgs {
	return &GetCellsArgs{}
}

func (p *GetCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetCellsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetCellsArgs) readField3(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *GetCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetCellsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetCellsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellsArgs(%+v)", *p)
}

type GetCellsResult struct {
	Success []*Cell          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetCellsResult() *GetCellsResult {
	return &GetCellsResult{}
}

func (p *GetCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem533 := NewCell()
		if err := _elem533.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem533)
		}
		p.Success = append(p.Success, _elem533)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellsResult(%+v)", *p)
}

type GetCellsAsArraysArgs struct {
	Ns       Namespace `thrift:"ns,1"`
	Name     string    `thrift:"name,2"`
	ScanSpec *ScanSpec `thrift:"scan_spec,3"`
}

func NewGetCellsAsArraysArgs() *GetCellsAsArraysArgs {
	return &GetCellsAsArraysArgs{}
}

func (p *GetCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetCellsAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *GetCellsAsArraysArgs) readField3(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *GetCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetCellsAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *GetCellsAsArraysArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellsAsArraysArgs(%+v)", *p)
}

type GetCellsAsArraysResult struct {
	Success []CellAsArray    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetCellsAsArraysResult() *GetCellsAsArraysResult {
	return &GetCellsAsArraysResult{}
}

func (p *GetCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellsAsArraysResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem534 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem535 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem535 = v
			}
			_elem534 = append(_elem534, _elem535)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success = append(p.Success, _elem534)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellsAsArraysResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellsAsArraysResult(%+v)", *p)
}

type GetCellsSerializedArgs struct {
	Ns       Namespace `thrift:"ns,1"`
	Name     string    `thrift:"name,2"`
	ScanSpec *ScanSpec `thrift:"scan_spec,3"`
}

func NewGetCellsSerializedArgs() *GetCellsSerializedArgs {
	return &GetCellsSerializedArgs{}
}

func (p *GetCellsSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellsSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetCellsSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *GetCellsSerializedArgs) readField3(iprot thrift.TProtocol) error {
	p.ScanSpec = NewScanSpec()
	if err := p.ScanSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ScanSpec)
	}
	return nil
}

func (p *GetCellsSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cells_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellsSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetCellsSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *GetCellsSerializedArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ScanSpec != nil {
		if err := oprot.WriteFieldBegin("scan_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:scan_spec: %s", p, err)
		}
		if err := p.ScanSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ScanSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:scan_spec: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellsSerializedArgs(%+v)", *p)
}

type GetCellsSerializedResult struct {
	Success CellsSerialized  `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetCellsSerializedResult() *GetCellsSerializedResult {
	return &GetCellsSerializedResult{}
}

func (p *GetCellsSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCellsSerializedResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = CellsSerialized(v)
	}
	return nil
}

func (p *GetCellsSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetCellsSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_cells_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCellsSerializedResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.BINARY, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetCellsSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCellsSerializedResult(%+v)", *p)
}

type SharedMutatorRefreshArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
}

func NewSharedMutatorRefreshArgs() *SharedMutatorRefreshArgs {
	return &SharedMutatorRefreshArgs{}
}

func (p *SharedMutatorRefreshArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorRefreshArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SharedMutatorRefreshArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SharedMutatorRefreshArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *SharedMutatorRefreshArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_refresh_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorRefreshArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SharedMutatorRefreshArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SharedMutatorRefreshArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorRefreshArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorRefreshArgs(%+v)", *p)
}

type SharedMutatorRefreshResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSharedMutatorRefreshResult() *SharedMutatorRefreshResult {
	return &SharedMutatorRefreshResult{}
}

func (p *SharedMutatorRefreshResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorRefreshResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SharedMutatorRefreshResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_refresh_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorRefreshResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorRefreshResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorRefreshResult(%+v)", *p)
}

type RefreshSharedMutatorArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
}

func NewRefreshSharedMutatorArgs() *RefreshSharedMutatorArgs {
	return &RefreshSharedMutatorArgs{}
}

func (p *RefreshSharedMutatorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RefreshSharedMutatorArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *RefreshSharedMutatorArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *RefreshSharedMutatorArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *RefreshSharedMutatorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refresh_shared_mutator_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RefreshSharedMutatorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *RefreshSharedMutatorArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *RefreshSharedMutatorArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *RefreshSharedMutatorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RefreshSharedMutatorArgs(%+v)", *p)
}

type RefreshSharedMutatorResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewRefreshSharedMutatorResult() *RefreshSharedMutatorResult {
	return &RefreshSharedMutatorResult{}
}

func (p *RefreshSharedMutatorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RefreshSharedMutatorResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *RefreshSharedMutatorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refresh_shared_mutator_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RefreshSharedMutatorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *RefreshSharedMutatorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RefreshSharedMutatorResult(%+v)", *p)
}

type SharedMutatorSetCellsArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
	Cells      []*Cell     `thrift:"cells,4"`
}

func NewSharedMutatorSetCellsArgs() *SharedMutatorSetCellsArgs {
	return &SharedMutatorSetCellsArgs{}
}

func (p *SharedMutatorSetCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SharedMutatorSetCellsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SharedMutatorSetCellsArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *SharedMutatorSetCellsArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem536 := NewCell()
		if err := _elem536.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem536)
		}
		p.Cells = append(p.Cells, _elem536)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SharedMutatorSetCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cells: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellsArgs(%+v)", *p)
}

type SharedMutatorSetCellsResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSharedMutatorSetCellsResult() *SharedMutatorSetCellsResult {
	return &SharedMutatorSetCellsResult{}
}

func (p *SharedMutatorSetCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SharedMutatorSetCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellsResult(%+v)", *p)
}

type OfferCellsArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
	Cells      []*Cell     `thrift:"cells,4"`
}

func NewOfferCellsArgs() *OfferCellsArgs {
	return &OfferCellsArgs{}
}

func (p *OfferCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OfferCellsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OfferCellsArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *OfferCellsArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem537 := NewCell()
		if err := _elem537.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem537)
		}
		p.Cells = append(p.Cells, _elem537)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *OfferCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OfferCellsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OfferCellsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cells: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellsArgs(%+v)", *p)
}

type OfferCellsResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewOfferCellsResult() *OfferCellsResult {
	return &OfferCellsResult{}
}

func (p *OfferCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OfferCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellsResult(%+v)", *p)
}

type SharedMutatorSetCellsAsArraysArgs struct {
	Ns         Namespace     `thrift:"ns,1"`
	TableName  string        `thrift:"table_name,2"`
	MutateSpec *MutateSpec   `thrift:"mutate_spec,3"`
	Cells      []CellAsArray `thrift:"cells,4"`
}

func NewSharedMutatorSetCellsAsArraysArgs() *SharedMutatorSetCellsAsArraysArgs {
	return &SharedMutatorSetCellsAsArraysArgs{}
}

func (p *SharedMutatorSetCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem538 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem539 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem539 = v
			}
			_elem538 = append(_elem538, _elem539)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Cells = append(p.Cells, _elem538)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellsAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellsAsArraysArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellsAsArraysArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cells: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellsAsArraysArgs(%+v)", *p)
}

type SharedMutatorSetCellsAsArraysResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSharedMutatorSetCellsAsArraysResult() *SharedMutatorSetCellsAsArraysResult {
	return &SharedMutatorSetCellsAsArraysResult{}
}

func (p *SharedMutatorSetCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellsAsArraysResult(%+v)", *p)
}

type OfferCellsAsArraysArgs struct {
	Ns         Namespace     `thrift:"ns,1"`
	TableName  string        `thrift:"table_name,2"`
	MutateSpec *MutateSpec   `thrift:"mutate_spec,3"`
	Cells      []CellAsArray `thrift:"cells,4"`
}

func NewOfferCellsAsArraysArgs() *OfferCellsAsArraysArgs {
	return &OfferCellsAsArraysArgs{}
}

func (p *OfferCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OfferCellsAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OfferCellsAsArraysArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *OfferCellsAsArraysArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem540 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem541 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem541 = v
			}
			_elem540 = append(_elem540, _elem541)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Cells = append(p.Cells, _elem540)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *OfferCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OfferCellsAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OfferCellsAsArraysArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellsAsArraysArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cells: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellsAsArraysArgs(%+v)", *p)
}

type OfferCellsAsArraysResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewOfferCellsAsArraysResult() *OfferCellsAsArraysResult {
	return &OfferCellsAsArraysResult{}
}

func (p *OfferCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OfferCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellsAsArraysResult(%+v)", *p)
}

type SharedMutatorSetCellArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
	Cell       *Cell       `thrift:"cell,4"`
}

func NewSharedMutatorSetCellArgs() *SharedMutatorSetCellArgs {
	return &SharedMutatorSetCellArgs{}
}

func (p *SharedMutatorSetCellArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SharedMutatorSetCellArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SharedMutatorSetCellArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *SharedMutatorSetCellArgs) readField4(iprot thrift.TProtocol) error {
	p.Cell = NewCell()
	if err := p.Cell.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Cell)
	}
	return nil
}

func (p *SharedMutatorSetCellArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cell_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cell: %s", p, err)
		}
		if err := p.Cell.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Cell)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cell: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellArgs(%+v)", *p)
}

type SharedMutatorSetCellResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSharedMutatorSetCellResult() *SharedMutatorSetCellResult {
	return &SharedMutatorSetCellResult{}
}

func (p *SharedMutatorSetCellResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SharedMutatorSetCellResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cell_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellResult(%+v)", *p)
}

type OfferCellArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
	Cell       *Cell       `thrift:"cell,4"`
}

func NewOfferCellArgs() *OfferCellArgs {
	return &OfferCellArgs{}
}

func (p *OfferCellArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OfferCellArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OfferCellArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *OfferCellArgs) readField4(iprot thrift.TProtocol) error {
	p.Cell = NewCell()
	if err := p.Cell.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Cell)
	}
	return nil
}

func (p *OfferCellArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cell_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OfferCellArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OfferCellArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cell: %s", p, err)
		}
		if err := p.Cell.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Cell)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cell: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellArgs(%+v)", *p)
}

type OfferCellResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewOfferCellResult() *OfferCellResult {
	return &OfferCellResult{}
}

func (p *OfferCellResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OfferCellResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cell_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellResult(%+v)", *p)
}

type SharedMutatorSetCellAsArrayArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
	Cell       CellAsArray `thrift:"cell,4"`
}

func NewSharedMutatorSetCellAsArrayArgs() *SharedMutatorSetCellAsArrayArgs {
	return &SharedMutatorSetCellAsArrayArgs{}
}

func (p *SharedMutatorSetCellAsArrayArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cell = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem542 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem542 = v
		}
		p.Cell = append(p.Cell, _elem542)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cell_as_array_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellAsArrayArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SharedMutatorSetCellAsArrayArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellAsArrayArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cell: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Cell)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cell {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cell: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellAsArrayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellAsArrayArgs(%+v)", *p)
}

type SharedMutatorSetCellAsArrayResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSharedMutatorSetCellAsArrayResult() *SharedMutatorSetCellAsArrayResult {
	return &SharedMutatorSetCellAsArrayResult{}
}

func (p *SharedMutatorSetCellAsArrayResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("shared_mutator_set_cell_as_array_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SharedMutatorSetCellAsArrayResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SharedMutatorSetCellAsArrayResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SharedMutatorSetCellAsArrayResult(%+v)", *p)
}

type OfferCellAsArrayArgs struct {
	Ns         Namespace   `thrift:"ns,1"`
	TableName  string      `thrift:"table_name,2"`
	MutateSpec *MutateSpec `thrift:"mutate_spec,3"`
	Cell       CellAsArray `thrift:"cell,4"`
}

func NewOfferCellAsArrayArgs() *OfferCellAsArrayArgs {
	return &OfferCellAsArrayArgs{}
}

func (p *OfferCellAsArrayArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellAsArrayArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OfferCellAsArrayArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OfferCellAsArrayArgs) readField3(iprot thrift.TProtocol) error {
	p.MutateSpec = NewMutateSpec()
	if err := p.MutateSpec.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.MutateSpec)
	}
	return nil
}

func (p *OfferCellAsArrayArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cell = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem543 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem543 = v
		}
		p.Cell = append(p.Cell, _elem543)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *OfferCellAsArrayArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cell_as_array_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellAsArrayArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OfferCellAsArrayArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OfferCellAsArrayArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.MutateSpec != nil {
		if err := oprot.WriteFieldBegin("mutate_spec", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:mutate_spec: %s", p, err)
		}
		if err := p.MutateSpec.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.MutateSpec)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:mutate_spec: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellAsArrayArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:cell: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Cell)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cell {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:cell: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellAsArrayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellAsArrayArgs(%+v)", *p)
}

type OfferCellAsArrayResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewOfferCellAsArrayResult() *OfferCellAsArrayResult {
	return &OfferCellAsArrayResult{}
}

func (p *OfferCellAsArrayResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OfferCellAsArrayResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OfferCellAsArrayResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("offer_cell_as_array_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OfferCellAsArrayResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OfferCellAsArrayResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OfferCellAsArrayResult(%+v)", *p)
}

type MutatorOpenArgs struct {
	Ns            Namespace `thrift:"ns,1"`
	TableName     string    `thrift:"table_name,2"`
	Flags         int32     `thrift:"flags,3"`
	FlushInterval int32     `thrift:"flush_interval,4"`
}

func NewMutatorOpenArgs() *MutatorOpenArgs {
	return &MutatorOpenArgs{
		Flags: 0,

		FlushInterval: 0,
	}
}

func (p *MutatorOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *MutatorOpenArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *MutatorOpenArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Flags = v
	}
	return nil
}

func (p *MutatorOpenArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.FlushInterval = v
	}
	return nil
}

func (p *MutatorOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_open_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *MutatorOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *MutatorOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flags", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:flags: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Flags)); err != nil {
		return fmt.Errorf("%T.flags (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:flags: %s", p, err)
	}
	return err
}

func (p *MutatorOpenArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flush_interval", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:flush_interval: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.FlushInterval)); err != nil {
		return fmt.Errorf("%T.flush_interval (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:flush_interval: %s", p, err)
	}
	return err
}

func (p *MutatorOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorOpenArgs(%+v)", *p)
}

type MutatorOpenResult struct {
	Success Mutator          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewMutatorOpenResult() *MutatorOpenResult {
	return &MutatorOpenResult{}
}

func (p *MutatorOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Mutator(v)
	}
	return nil
}

func (p *MutatorOpenResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_open_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *MutatorOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorOpenResult(%+v)", *p)
}

type OpenMutatorArgs struct {
	Ns            Namespace `thrift:"ns,1"`
	TableName     string    `thrift:"table_name,2"`
	Flags         int32     `thrift:"flags,3"`
	FlushInterval int32     `thrift:"flush_interval,4"`
}

func NewOpenMutatorArgs() *OpenMutatorArgs {
	return &OpenMutatorArgs{
		Flags: 0,

		FlushInterval: 0,
	}
}

func (p *OpenMutatorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenMutatorArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OpenMutatorArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OpenMutatorArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Flags = v
	}
	return nil
}

func (p *OpenMutatorArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.FlushInterval = v
	}
	return nil
}

func (p *OpenMutatorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_mutator_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenMutatorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OpenMutatorArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OpenMutatorArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flags", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:flags: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Flags)); err != nil {
		return fmt.Errorf("%T.flags (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:flags: %s", p, err)
	}
	return err
}

func (p *OpenMutatorArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flush_interval", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:flush_interval: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.FlushInterval)); err != nil {
		return fmt.Errorf("%T.flush_interval (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:flush_interval: %s", p, err)
	}
	return err
}

func (p *OpenMutatorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenMutatorArgs(%+v)", *p)
}

type OpenMutatorResult struct {
	Success Mutator          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewOpenMutatorResult() *OpenMutatorResult {
	return &OpenMutatorResult{}
}

func (p *OpenMutatorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenMutatorResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = Mutator(v)
	}
	return nil
}

func (p *OpenMutatorResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OpenMutatorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_mutator_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenMutatorResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenMutatorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OpenMutatorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenMutatorResult(%+v)", *p)
}

type AsyncMutatorOpenArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Future    Future    `thrift:"future,3"`
	Flags     int32     `thrift:"flags,4"`
}

func NewAsyncMutatorOpenArgs() *AsyncMutatorOpenArgs {
	return &AsyncMutatorOpenArgs{
		Flags: 0,
	}
}

func (p *AsyncMutatorOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorOpenArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *AsyncMutatorOpenArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *AsyncMutatorOpenArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Future = Future(v)
	}
	return nil
}

func (p *AsyncMutatorOpenArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Flags = v
	}
	return nil
}

func (p *AsyncMutatorOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_open_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("future", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:future: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Future)); err != nil {
		return fmt.Errorf("%T.future (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:future: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorOpenArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flags", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:flags: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Flags)); err != nil {
		return fmt.Errorf("%T.flags (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:flags: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorOpenArgs(%+v)", *p)
}

type AsyncMutatorOpenResult struct {
	Success MutatorAsync     `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorOpenResult() *AsyncMutatorOpenResult {
	return &AsyncMutatorOpenResult{}
}

func (p *AsyncMutatorOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorOpenResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorOpenResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_open_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorOpenResult(%+v)", *p)
}

type OpenMutatorAsyncArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Future    Future    `thrift:"future,3"`
	Flags     int32     `thrift:"flags,4"`
}

func NewOpenMutatorAsyncArgs() *OpenMutatorAsyncArgs {
	return &OpenMutatorAsyncArgs{
		Flags: 0,
	}
}

func (p *OpenMutatorAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenMutatorAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *OpenMutatorAsyncArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *OpenMutatorAsyncArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Future = Future(v)
	}
	return nil
}

func (p *OpenMutatorAsyncArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Flags = v
	}
	return nil
}

func (p *OpenMutatorAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_mutator_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenMutatorAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *OpenMutatorAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *OpenMutatorAsyncArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("future", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:future: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Future)); err != nil {
		return fmt.Errorf("%T.future (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:future: %s", p, err)
	}
	return err
}

func (p *OpenMutatorAsyncArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flags", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:flags: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Flags)); err != nil {
		return fmt.Errorf("%T.flags (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:flags: %s", p, err)
	}
	return err
}

func (p *OpenMutatorAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenMutatorAsyncArgs(%+v)", *p)
}

type OpenMutatorAsyncResult struct {
	Success MutatorAsync     `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewOpenMutatorAsyncResult() *OpenMutatorAsyncResult {
	return &OpenMutatorAsyncResult{}
}

func (p *OpenMutatorAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenMutatorAsyncResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = MutatorAsync(v)
	}
	return nil
}

func (p *OpenMutatorAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *OpenMutatorAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("open_mutator_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenMutatorAsyncResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *OpenMutatorAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *OpenMutatorAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenMutatorAsyncResult(%+v)", *p)
}

type MutatorCloseArgs struct {
	Mutator Mutator `thrift:"mutator,1"`
}

func NewMutatorCloseArgs() *MutatorCloseArgs {
	return &MutatorCloseArgs{}
}

func (p *MutatorCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorCloseArgs(%+v)", *p)
}

type MutatorCloseResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorCloseResult() *MutatorCloseResult {
	return &MutatorCloseResult{}
}

func (p *MutatorCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorCloseResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorCloseResult(%+v)", *p)
}

type CloseMutatorArgs struct {
	Mutator Mutator `thrift:"mutator,1"`
}

func NewCloseMutatorArgs() *CloseMutatorArgs {
	return &CloseMutatorArgs{}
}

func (p *CloseMutatorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseMutatorArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *CloseMutatorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_mutator_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseMutatorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *CloseMutatorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseMutatorArgs(%+v)", *p)
}

type CloseMutatorResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCloseMutatorResult() *CloseMutatorResult {
	return &CloseMutatorResult{}
}

func (p *CloseMutatorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseMutatorResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CloseMutatorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_mutator_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseMutatorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CloseMutatorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseMutatorResult(%+v)", *p)
}

type AsyncMutatorCancelArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
}

func NewAsyncMutatorCancelArgs() *AsyncMutatorCancelArgs {
	return &AsyncMutatorCancelArgs{}
}

func (p *AsyncMutatorCancelArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorCancelArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorCancelArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_cancel_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorCancelArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorCancelArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorCancelArgs(%+v)", *p)
}

type AsyncMutatorCancelResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorCancelResult() *AsyncMutatorCancelResult {
	return &AsyncMutatorCancelResult{}
}

func (p *AsyncMutatorCancelResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorCancelResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorCancelResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_cancel_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorCancelResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorCancelResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorCancelResult(%+v)", *p)
}

type CancelMutatorAsyncArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
}

func NewCancelMutatorAsyncArgs() *CancelMutatorAsyncArgs {
	return &CancelMutatorAsyncArgs{}
}

func (p *CancelMutatorAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelMutatorAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *CancelMutatorAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancel_mutator_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelMutatorAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *CancelMutatorAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelMutatorAsyncArgs(%+v)", *p)
}

type CancelMutatorAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCancelMutatorAsyncResult() *CancelMutatorAsyncResult {
	return &CancelMutatorAsyncResult{}
}

func (p *CancelMutatorAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CancelMutatorAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CancelMutatorAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cancel_mutator_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CancelMutatorAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CancelMutatorAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CancelMutatorAsyncResult(%+v)", *p)
}

type AsyncMutatorCloseArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
}

func NewAsyncMutatorCloseArgs() *AsyncMutatorCloseArgs {
	return &AsyncMutatorCloseArgs{}
}

func (p *AsyncMutatorCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorCloseArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorCloseArgs(%+v)", *p)
}

type AsyncMutatorCloseResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorCloseResult() *AsyncMutatorCloseResult {
	return &AsyncMutatorCloseResult{}
}

func (p *AsyncMutatorCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorCloseResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorCloseResult(%+v)", *p)
}

type CloseMutatorAsyncArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
}

func NewCloseMutatorAsyncArgs() *CloseMutatorAsyncArgs {
	return &CloseMutatorAsyncArgs{}
}

func (p *CloseMutatorAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseMutatorAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *CloseMutatorAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_mutator_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseMutatorAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *CloseMutatorAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseMutatorAsyncArgs(%+v)", *p)
}

type CloseMutatorAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewCloseMutatorAsyncResult() *CloseMutatorAsyncResult {
	return &CloseMutatorAsyncResult{}
}

func (p *CloseMutatorAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseMutatorAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CloseMutatorAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_mutator_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseMutatorAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CloseMutatorAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseMutatorAsyncResult(%+v)", *p)
}

type MutatorSetCellArgs struct {
	Mutator Mutator `thrift:"mutator,1"`
	Cell    *Cell   `thrift:"cell,2"`
}

func NewMutatorSetCellArgs() *MutatorSetCellArgs {
	return &MutatorSetCellArgs{}
}

func (p *MutatorSetCellArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorSetCellArgs) readField2(iprot thrift.TProtocol) error {
	p.Cell = NewCell()
	if err := p.Cell.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Cell)
	}
	return nil
}

func (p *MutatorSetCellArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cell_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorSetCellArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cell: %s", p, err)
		}
		if err := p.Cell.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Cell)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cell: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellArgs(%+v)", *p)
}

type MutatorSetCellResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorSetCellResult() *MutatorSetCellResult {
	return &MutatorSetCellResult{}
}

func (p *MutatorSetCellResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorSetCellResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cell_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellResult(%+v)", *p)
}

type SetCellArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Cell      *Cell     `thrift:"cell,3"`
}

func NewSetCellArgs() *SetCellArgs {
	return &SetCellArgs{}
}

func (p *SetCellArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SetCellArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SetCellArgs) readField3(iprot thrift.TProtocol) error {
	p.Cell = NewCell()
	if err := p.Cell.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Cell)
	}
	return nil
}

func (p *SetCellArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SetCellArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SetCellArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:cell: %s", p, err)
		}
		if err := p.Cell.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Cell)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:cell: %s", p, err)
		}
	}
	return err
}

func (p *SetCellArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellArgs(%+v)", *p)
}

type SetCellResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellResult() *SetCellResult {
	return &SetCellResult{}
}

func (p *SetCellResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellResult(%+v)", *p)
}

type MutatorSetCellAsArrayArgs struct {
	Mutator Mutator     `thrift:"mutator,1"`
	Cell    CellAsArray `thrift:"cell,2"`
}

func NewMutatorSetCellAsArrayArgs() *MutatorSetCellAsArrayArgs {
	return &MutatorSetCellAsArrayArgs{}
}

func (p *MutatorSetCellAsArrayArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellAsArrayArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorSetCellAsArrayArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cell = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem544 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem544 = v
		}
		p.Cell = append(p.Cell, _elem544)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutatorSetCellAsArrayArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cell_as_array_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellAsArrayArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorSetCellAsArrayArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cell: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Cell)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cell {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cell: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellAsArrayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellAsArrayArgs(%+v)", *p)
}

type MutatorSetCellAsArrayResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorSetCellAsArrayResult() *MutatorSetCellAsArrayResult {
	return &MutatorSetCellAsArrayResult{}
}

func (p *MutatorSetCellAsArrayResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellAsArrayResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorSetCellAsArrayResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cell_as_array_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellAsArrayResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellAsArrayResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellAsArrayResult(%+v)", *p)
}

type SetCellAsArrayArgs struct {
	Ns        Namespace   `thrift:"ns,1"`
	TableName string      `thrift:"table_name,2"`
	Cell      CellAsArray `thrift:"cell,3"`
}

func NewSetCellAsArrayArgs() *SetCellAsArrayArgs {
	return &SetCellAsArrayArgs{}
}

func (p *SetCellAsArrayArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellAsArrayArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SetCellAsArrayArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SetCellAsArrayArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cell = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem545 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem545 = v
		}
		p.Cell = append(p.Cell, _elem545)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SetCellAsArrayArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_as_array_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellAsArrayArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SetCellAsArrayArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SetCellAsArrayArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:cell: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Cell)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cell {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:cell: %s", p, err)
		}
	}
	return err
}

func (p *SetCellAsArrayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellAsArrayArgs(%+v)", *p)
}

type SetCellAsArrayResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellAsArrayResult() *SetCellAsArrayResult {
	return &SetCellAsArrayResult{}
}

func (p *SetCellAsArrayResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellAsArrayResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellAsArrayResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_as_array_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellAsArrayResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellAsArrayResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellAsArrayResult(%+v)", *p)
}

type MutatorSetCellsArgs struct {
	Mutator Mutator `thrift:"mutator,1"`
	Cells   []*Cell `thrift:"cells,2"`
}

func NewMutatorSetCellsArgs() *MutatorSetCellsArgs {
	return &MutatorSetCellsArgs{}
}

func (p *MutatorSetCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorSetCellsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem546 := NewCell()
		if err := _elem546.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem546)
		}
		p.Cells = append(p.Cells, _elem546)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutatorSetCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorSetCellsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellsArgs(%+v)", *p)
}

type MutatorSetCellsResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorSetCellsResult() *MutatorSetCellsResult {
	return &MutatorSetCellsResult{}
}

func (p *MutatorSetCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorSetCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellsResult(%+v)", *p)
}

type SetCellsArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Cells     []*Cell   `thrift:"cells,3"`
}

func NewSetCellsArgs() *SetCellsArgs {
	return &SetCellsArgs{}
}

func (p *SetCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SetCellsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SetCellsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem547 := NewCell()
		if err := _elem547.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem547)
		}
		p.Cells = append(p.Cells, _elem547)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SetCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SetCellsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SetCellsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:cells: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsArgs(%+v)", *p)
}

type SetCellsResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellsResult() *SetCellsResult {
	return &SetCellsResult{}
}

func (p *SetCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsResult(%+v)", *p)
}

type MutatorSetCellsAsArraysArgs struct {
	Mutator Mutator       `thrift:"mutator,1"`
	Cells   []CellAsArray `thrift:"cells,2"`
}

func NewMutatorSetCellsAsArraysArgs() *MutatorSetCellsAsArraysArgs {
	return &MutatorSetCellsAsArraysArgs{}
}

func (p *MutatorSetCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorSetCellsAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem548 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem549 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem549 = v
			}
			_elem548 = append(_elem548, _elem549)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Cells = append(p.Cells, _elem548)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MutatorSetCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorSetCellsAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellsAsArraysArgs(%+v)", *p)
}

type MutatorSetCellsAsArraysResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorSetCellsAsArraysResult() *MutatorSetCellsAsArraysResult {
	return &MutatorSetCellsAsArraysResult{}
}

func (p *MutatorSetCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorSetCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellsAsArraysResult(%+v)", *p)
}

type SetCellsAsArraysArgs struct {
	Ns        Namespace     `thrift:"ns,1"`
	TableName string        `thrift:"table_name,2"`
	Cells     []CellAsArray `thrift:"cells,3"`
}

func NewSetCellsAsArraysArgs() *SetCellsAsArraysArgs {
	return &SetCellsAsArraysArgs{}
}

func (p *SetCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SetCellsAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SetCellsAsArraysArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem550 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem551 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem551 = v
			}
			_elem550 = append(_elem550, _elem551)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Cells = append(p.Cells, _elem550)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SetCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SetCellsAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SetCellsAsArraysArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:cells: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsAsArraysArgs(%+v)", *p)
}

type SetCellsAsArraysResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellsAsArraysResult() *SetCellsAsArraysResult {
	return &SetCellsAsArraysResult{}
}

func (p *SetCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsAsArraysResult(%+v)", *p)
}

type MutatorSetCellsSerializedArgs struct {
	Mutator Mutator         `thrift:"mutator,1"`
	Cells   CellsSerialized `thrift:"cells,2"`
	Flush   bool            `thrift:"flush,3"`
}

func NewMutatorSetCellsSerializedArgs() *MutatorSetCellsSerializedArgs {
	return &MutatorSetCellsSerializedArgs{
		Flush: false,
	}
}

func (p *MutatorSetCellsSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellsSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorSetCellsSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Cells = CellsSerialized(v)
	}
	return nil
}

func (p *MutatorSetCellsSerializedArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Flush = v
	}
	return nil
}

func (p *MutatorSetCellsSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cells_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellsSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorSetCellsSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Cells); err != nil {
			return fmt.Errorf("%T.cells (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellsSerializedArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flush", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:flush: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Flush)); err != nil {
		return fmt.Errorf("%T.flush (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:flush: %s", p, err)
	}
	return err
}

func (p *MutatorSetCellsSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellsSerializedArgs(%+v)", *p)
}

type MutatorSetCellsSerializedResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorSetCellsSerializedResult() *MutatorSetCellsSerializedResult {
	return &MutatorSetCellsSerializedResult{}
}

func (p *MutatorSetCellsSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorSetCellsSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorSetCellsSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_set_cells_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorSetCellsSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorSetCellsSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorSetCellsSerializedResult(%+v)", *p)
}

type SetCellsSerializedArgs struct {
	Ns        Namespace       `thrift:"ns,1"`
	TableName string          `thrift:"table_name,2"`
	Cells     CellsSerialized `thrift:"cells,3"`
}

func NewSetCellsSerializedArgs() *SetCellsSerializedArgs {
	return &SetCellsSerializedArgs{}
}

func (p *SetCellsSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *SetCellsSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *SetCellsSerializedArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Cells = CellsSerialized(v)
	}
	return nil
}

func (p *SetCellsSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *SetCellsSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *SetCellsSerializedArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.BINARY, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:cells: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Cells); err != nil {
			return fmt.Errorf("%T.cells (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:cells: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsSerializedArgs(%+v)", *p)
}

type SetCellsSerializedResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellsSerializedResult() *SetCellsSerializedResult {
	return &SetCellsSerializedResult{}
}

func (p *SetCellsSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellsSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsSerializedResult(%+v)", *p)
}

type MutatorFlushArgs struct {
	Mutator Mutator `thrift:"mutator,1"`
}

func NewMutatorFlushArgs() *MutatorFlushArgs {
	return &MutatorFlushArgs{}
}

func (p *MutatorFlushArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorFlushArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *MutatorFlushArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_flush_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorFlushArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *MutatorFlushArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorFlushArgs(%+v)", *p)
}

type MutatorFlushResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewMutatorFlushResult() *MutatorFlushResult {
	return &MutatorFlushResult{}
}

func (p *MutatorFlushResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutatorFlushResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *MutatorFlushResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutator_flush_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MutatorFlushResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *MutatorFlushResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutatorFlushResult(%+v)", *p)
}

type FlushMutatorArgs struct {
	Mutator Mutator `thrift:"mutator,1"`
}

func NewFlushMutatorArgs() *FlushMutatorArgs {
	return &FlushMutatorArgs{}
}

func (p *FlushMutatorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FlushMutatorArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = Mutator(v)
	}
	return nil
}

func (p *FlushMutatorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("flush_mutator_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FlushMutatorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *FlushMutatorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FlushMutatorArgs(%+v)", *p)
}

type FlushMutatorResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewFlushMutatorResult() *FlushMutatorResult {
	return &FlushMutatorResult{}
}

func (p *FlushMutatorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FlushMutatorResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FlushMutatorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("flush_mutator_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FlushMutatorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FlushMutatorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FlushMutatorResult(%+v)", *p)
}

type AsyncMutatorSetCellArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
	Cell    *Cell        `thrift:"cell,2"`
}

func NewAsyncMutatorSetCellArgs() *AsyncMutatorSetCellArgs {
	return &AsyncMutatorSetCellArgs{}
}

func (p *AsyncMutatorSetCellArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorSetCellArgs) readField2(iprot thrift.TProtocol) error {
	p.Cell = NewCell()
	if err := p.Cell.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Cell)
	}
	return nil
}

func (p *AsyncMutatorSetCellArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cell_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorSetCellArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cell: %s", p, err)
		}
		if err := p.Cell.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Cell)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cell: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellArgs(%+v)", *p)
}

type AsyncMutatorSetCellResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorSetCellResult() *AsyncMutatorSetCellResult {
	return &AsyncMutatorSetCellResult{}
}

func (p *AsyncMutatorSetCellResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorSetCellResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cell_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellResult(%+v)", *p)
}

type SetCellAsyncArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
	Cell    *Cell        `thrift:"cell,2"`
}

func NewSetCellAsyncArgs() *SetCellAsyncArgs {
	return &SetCellAsyncArgs{}
}

func (p *SetCellAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *SetCellAsyncArgs) readField2(iprot thrift.TProtocol) error {
	p.Cell = NewCell()
	if err := p.Cell.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Cell)
	}
	return nil
}

func (p *SetCellAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *SetCellAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cell: %s", p, err)
		}
		if err := p.Cell.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Cell)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cell: %s", p, err)
		}
	}
	return err
}

func (p *SetCellAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellAsyncArgs(%+v)", *p)
}

type SetCellAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellAsyncResult() *SetCellAsyncResult {
	return &SetCellAsyncResult{}
}

func (p *SetCellAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellAsyncResult(%+v)", *p)
}

type AsyncMutatorSetCellAsArrayArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
	Cell    CellAsArray  `thrift:"cell,2"`
}

func NewAsyncMutatorSetCellAsArrayArgs() *AsyncMutatorSetCellAsArrayArgs {
	return &AsyncMutatorSetCellAsArrayArgs{}
}

func (p *AsyncMutatorSetCellAsArrayArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cell = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem552 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem552 = v
		}
		p.Cell = append(p.Cell, _elem552)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cell_as_array_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorSetCellAsArrayArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cell: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Cell)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cell {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cell: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellAsArrayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellAsArrayArgs(%+v)", *p)
}

type AsyncMutatorSetCellAsArrayResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorSetCellAsArrayResult() *AsyncMutatorSetCellAsArrayResult {
	return &AsyncMutatorSetCellAsArrayResult{}
}

func (p *AsyncMutatorSetCellAsArrayResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cell_as_array_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellAsArrayResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellAsArrayResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellAsArrayResult(%+v)", *p)
}

type SetCellAsArrayAsyncArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
	Cell    CellAsArray  `thrift:"cell,2"`
}

func NewSetCellAsArrayAsyncArgs() *SetCellAsArrayAsyncArgs {
	return &SetCellAsArrayAsyncArgs{}
}

func (p *SetCellAsArrayAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellAsArrayAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *SetCellAsArrayAsyncArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cell = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem553 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem553 = v
		}
		p.Cell = append(p.Cell, _elem553)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SetCellAsArrayAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_as_array_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellAsArrayAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *SetCellAsArrayAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cell != nil {
		if err := oprot.WriteFieldBegin("cell", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cell: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Cell)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cell {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cell: %s", p, err)
		}
	}
	return err
}

func (p *SetCellAsArrayAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellAsArrayAsyncArgs(%+v)", *p)
}

type SetCellAsArrayAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellAsArrayAsyncResult() *SetCellAsArrayAsyncResult {
	return &SetCellAsArrayAsyncResult{}
}

func (p *SetCellAsArrayAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellAsArrayAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellAsArrayAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cell_as_array_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellAsArrayAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellAsArrayAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellAsArrayAsyncResult(%+v)", *p)
}

type AsyncMutatorSetCellsArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
	Cells   []*Cell      `thrift:"cells,2"`
}

func NewAsyncMutatorSetCellsArgs() *AsyncMutatorSetCellsArgs {
	return &AsyncMutatorSetCellsArgs{}
}

func (p *AsyncMutatorSetCellsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorSetCellsArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem554 := NewCell()
		if err := _elem554.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem554)
		}
		p.Cells = append(p.Cells, _elem554)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *AsyncMutatorSetCellsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cells_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorSetCellsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellsArgs(%+v)", *p)
}

type AsyncMutatorSetCellsResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorSetCellsResult() *AsyncMutatorSetCellsResult {
	return &AsyncMutatorSetCellsResult{}
}

func (p *AsyncMutatorSetCellsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorSetCellsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cells_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellsResult(%+v)", *p)
}

type SetCellsAsyncArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
	Cells   []*Cell      `thrift:"cells,2"`
}

func NewSetCellsAsyncArgs() *SetCellsAsyncArgs {
	return &SetCellsAsyncArgs{}
}

func (p *SetCellsAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *SetCellsAsyncArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]*Cell, 0, size)
	for i := 0; i < size; i++ {
		_elem555 := NewCell()
		if err := _elem555.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem555)
		}
		p.Cells = append(p.Cells, _elem555)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SetCellsAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *SetCellsAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsAsyncArgs(%+v)", *p)
}

type SetCellsAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellsAsyncResult() *SetCellsAsyncResult {
	return &SetCellsAsyncResult{}
}

func (p *SetCellsAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellsAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsAsyncResult(%+v)", *p)
}

type AsyncMutatorSetCellsAsArraysArgs struct {
	Mutator MutatorAsync  `thrift:"mutator,1"`
	Cells   []CellAsArray `thrift:"cells,2"`
}

func NewAsyncMutatorSetCellsAsArraysArgs() *AsyncMutatorSetCellsAsArraysArgs {
	return &AsyncMutatorSetCellsAsArraysArgs{}
}

func (p *AsyncMutatorSetCellsAsArraysArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem556 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem557 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem557 = v
			}
			_elem556 = append(_elem556, _elem557)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Cells = append(p.Cells, _elem556)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cells_as_arrays_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorSetCellsAsArraysArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellsAsArraysArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellsAsArraysArgs(%+v)", *p)
}

type AsyncMutatorSetCellsAsArraysResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorSetCellsAsArraysResult() *AsyncMutatorSetCellsAsArraysResult {
	return &AsyncMutatorSetCellsAsArraysResult{}
}

func (p *AsyncMutatorSetCellsAsArraysResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cells_as_arrays_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsAsArraysResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellsAsArraysResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellsAsArraysResult(%+v)", *p)
}

type SetCellsAsArraysAsyncArgs struct {
	Mutator MutatorAsync  `thrift:"mutator,1"`
	Cells   []CellAsArray `thrift:"cells,2"`
}

func NewSetCellsAsArraysAsyncArgs() *SetCellsAsArraysAsyncArgs {
	return &SetCellsAsArraysAsyncArgs{}
}

func (p *SetCellsAsArraysAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsAsArraysAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *SetCellsAsArraysAsyncArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Cells = make([]CellAsArray, 0, size)
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_elem558 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem559 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem559 = v
			}
			_elem558 = append(_elem558, _elem559)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Cells = append(p.Cells, _elem558)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SetCellsAsArraysAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_as_arrays_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsAsArraysAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *SetCellsAsArraysAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.Cells)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Cells {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsAsArraysAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsAsArraysAsyncArgs(%+v)", *p)
}

type SetCellsAsArraysAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellsAsArraysAsyncResult() *SetCellsAsArraysAsyncResult {
	return &SetCellsAsArraysAsyncResult{}
}

func (p *SetCellsAsArraysAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsAsArraysAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellsAsArraysAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_as_arrays_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsAsArraysAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsAsArraysAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsAsArraysAsyncResult(%+v)", *p)
}

type AsyncMutatorSetCellsSerializedArgs struct {
	Mutator MutatorAsync    `thrift:"mutator,1"`
	Cells   CellsSerialized `thrift:"cells,2"`
	Flush   bool            `thrift:"flush,3"`
}

func NewAsyncMutatorSetCellsSerializedArgs() *AsyncMutatorSetCellsSerializedArgs {
	return &AsyncMutatorSetCellsSerializedArgs{
		Flush: false,
	}
}

func (p *AsyncMutatorSetCellsSerializedArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Cells = CellsSerialized(v)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Flush = v
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cells_serialized_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorSetCellsSerializedArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Cells); err != nil {
			return fmt.Errorf("%T.cells (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellsSerializedArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flush", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:flush: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Flush)); err != nil {
		return fmt.Errorf("%T.flush (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:flush: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorSetCellsSerializedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellsSerializedArgs(%+v)", *p)
}

type AsyncMutatorSetCellsSerializedResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorSetCellsSerializedResult() *AsyncMutatorSetCellsSerializedResult {
	return &AsyncMutatorSetCellsSerializedResult{}
}

func (p *AsyncMutatorSetCellsSerializedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_set_cells_serialized_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorSetCellsSerializedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorSetCellsSerializedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorSetCellsSerializedResult(%+v)", *p)
}

type SetCellsSerializedAsyncArgs struct {
	Mutator MutatorAsync    `thrift:"mutator,1"`
	Cells   CellsSerialized `thrift:"cells,2"`
	Flush   bool            `thrift:"flush,3"`
}

func NewSetCellsSerializedAsyncArgs() *SetCellsSerializedAsyncArgs {
	return &SetCellsSerializedAsyncArgs{
		Flush: false,
	}
}

func (p *SetCellsSerializedAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsSerializedAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *SetCellsSerializedAsyncArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Cells = CellsSerialized(v)
	}
	return nil
}

func (p *SetCellsSerializedAsyncArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Flush = v
	}
	return nil
}

func (p *SetCellsSerializedAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_serialized_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsSerializedAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *SetCellsSerializedAsyncArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Cells != nil {
		if err := oprot.WriteFieldBegin("cells", thrift.BINARY, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:cells: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Cells); err != nil {
			return fmt.Errorf("%T.cells (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:cells: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsSerializedAsyncArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("flush", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:flush: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Flush)); err != nil {
		return fmt.Errorf("%T.flush (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:flush: %s", p, err)
	}
	return err
}

func (p *SetCellsSerializedAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsSerializedAsyncArgs(%+v)", *p)
}

type SetCellsSerializedAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewSetCellsSerializedAsyncResult() *SetCellsSerializedAsyncResult {
	return &SetCellsSerializedAsyncResult{}
}

func (p *SetCellsSerializedAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCellsSerializedAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *SetCellsSerializedAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cells_serialized_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCellsSerializedAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SetCellsSerializedAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCellsSerializedAsyncResult(%+v)", *p)
}

type AsyncMutatorFlushArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
}

func NewAsyncMutatorFlushArgs() *AsyncMutatorFlushArgs {
	return &AsyncMutatorFlushArgs{}
}

func (p *AsyncMutatorFlushArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorFlushArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *AsyncMutatorFlushArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_flush_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorFlushArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *AsyncMutatorFlushArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorFlushArgs(%+v)", *p)
}

type AsyncMutatorFlushResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewAsyncMutatorFlushResult() *AsyncMutatorFlushResult {
	return &AsyncMutatorFlushResult{}
}

func (p *AsyncMutatorFlushResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AsyncMutatorFlushResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *AsyncMutatorFlushResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("async_mutator_flush_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AsyncMutatorFlushResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *AsyncMutatorFlushResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AsyncMutatorFlushResult(%+v)", *p)
}

type FlushMutatorAsyncArgs struct {
	Mutator MutatorAsync `thrift:"mutator,1"`
}

func NewFlushMutatorAsyncArgs() *FlushMutatorAsyncArgs {
	return &FlushMutatorAsyncArgs{}
}

func (p *FlushMutatorAsyncArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FlushMutatorAsyncArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Mutator = MutatorAsync(v)
	}
	return nil
}

func (p *FlushMutatorAsyncArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("flush_mutator_async_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FlushMutatorAsyncArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutator", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutator: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Mutator)); err != nil {
		return fmt.Errorf("%T.mutator (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutator: %s", p, err)
	}
	return err
}

func (p *FlushMutatorAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FlushMutatorAsyncArgs(%+v)", *p)
}

type FlushMutatorAsyncResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewFlushMutatorAsyncResult() *FlushMutatorAsyncResult {
	return &FlushMutatorAsyncResult{}
}

func (p *FlushMutatorAsyncResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FlushMutatorAsyncResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *FlushMutatorAsyncResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("flush_mutator_async_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *FlushMutatorAsyncResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *FlushMutatorAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FlushMutatorAsyncResult(%+v)", *p)
}

type NamespaceExistsArgs struct {
	Ns string `thrift:"ns,1"`
}

func NewNamespaceExistsArgs() *NamespaceExistsArgs {
	return &NamespaceExistsArgs{}
}

func (p *NamespaceExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceExistsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *NamespaceExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_exists_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *NamespaceExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceExistsArgs(%+v)", *p)
}

type NamespaceExistsResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewNamespaceExistsResult() *NamespaceExistsResult {
	return &NamespaceExistsResult{}
}

func (p *NamespaceExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceExistsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *NamespaceExistsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NamespaceExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_exists_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *NamespaceExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceExistsResult(%+v)", *p)
}

type ExistsNamespaceArgs struct {
	Ns string `thrift:"ns,1"`
}

func NewExistsNamespaceArgs() *ExistsNamespaceArgs {
	return &ExistsNamespaceArgs{}
}

func (p *ExistsNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *ExistsNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_namespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *ExistsNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsNamespaceArgs(%+v)", *p)
}

type ExistsNamespaceResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewExistsNamespaceResult() *ExistsNamespaceResult {
	return &ExistsNamespaceResult{}
}

func (p *ExistsNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsNamespaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExistsNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ExistsNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_namespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsNamespaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExistsNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ExistsNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsNamespaceResult(%+v)", *p)
}

type ExistsTableArgs struct {
	Ns   Namespace `thrift:"ns,1"`
	Name string    `thrift:"name,2"`
}

func NewExistsTableArgs() *ExistsTableArgs {
	return &ExistsTableArgs{}
}

func (p *ExistsTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *ExistsTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *ExistsTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_table_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *ExistsTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *ExistsTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsTableArgs(%+v)", *p)
}

type ExistsTableResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewExistsTableResult() *ExistsTableResult {
	return &ExistsTableResult{}
}

func (p *ExistsTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsTableResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ExistsTableResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *ExistsTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_table_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsTableResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ExistsTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ExistsTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsTableResult(%+v)", *p)
}

type TableExistsArgs struct {
	Ns   Namespace `thrift:"ns,1"`
	Name string    `thrift:"name,2"`
}

func NewTableExistsArgs() *TableExistsArgs {
	return &TableExistsArgs{}
}

func (p *TableExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableExistsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableExistsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *TableExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_exists_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableExistsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *TableExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableExistsArgs(%+v)", *p)
}

type TableExistsResult struct {
	Success bool             `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewTableExistsResult() *TableExistsResult {
	return &TableExistsResult{}
}

func (p *TableExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableExistsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *TableExistsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_exists_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *TableExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableExistsResult(%+v)", *p)
}

type TableGetIdArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewTableGetIdArgs() *TableGetIdArgs {
	return &TableGetIdArgs{}
}

func (p *TableGetIdArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetIdArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableGetIdArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableGetIdArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_id_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetIdArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableGetIdArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableGetIdArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetIdArgs(%+v)", *p)
}

type TableGetIdResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewTableGetIdResult() *TableGetIdResult {
	return &TableGetIdResult{}
}

func (p *TableGetIdResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetIdResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *TableGetIdResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableGetIdResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_id_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetIdResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *TableGetIdResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableGetIdResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetIdResult(%+v)", *p)
}

type GetTableIdArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewGetTableIdArgs() *GetTableIdArgs {
	return &GetTableIdArgs{}
}

func (p *GetTableIdArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableIdArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetTableIdArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetTableIdArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_table_id_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableIdArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetTableIdArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetTableIdArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableIdArgs(%+v)", *p)
}

type GetTableIdResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetTableIdResult() *GetTableIdResult {
	return &GetTableIdResult{}
}

func (p *GetTableIdResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableIdResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetTableIdResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetTableIdResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_table_id_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableIdResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetTableIdResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetTableIdResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableIdResult(%+v)", *p)
}

type TableGetSchemaStrArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewTableGetSchemaStrArgs() *TableGetSchemaStrArgs {
	return &TableGetSchemaStrArgs{}
}

func (p *TableGetSchemaStrArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSchemaStrArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableGetSchemaStrArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableGetSchemaStrArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_schema_str_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSchemaStrArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaStrArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaStrArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSchemaStrArgs(%+v)", *p)
}

type TableGetSchemaStrResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewTableGetSchemaStrResult() *TableGetSchemaStrResult {
	return &TableGetSchemaStrResult{}
}

func (p *TableGetSchemaStrResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSchemaStrResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *TableGetSchemaStrResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableGetSchemaStrResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_schema_str_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSchemaStrResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaStrResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableGetSchemaStrResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSchemaStrResult(%+v)", *p)
}

type GetSchemaStrArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewGetSchemaStrArgs() *GetSchemaStrArgs {
	return &GetSchemaStrArgs{}
}

func (p *GetSchemaStrArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemaStrArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetSchemaStrArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetSchemaStrArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_schema_str_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemaStrArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetSchemaStrArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetSchemaStrArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemaStrArgs(%+v)", *p)
}

type GetSchemaStrResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetSchemaStrResult() *GetSchemaStrResult {
	return &GetSchemaStrResult{}
}

func (p *GetSchemaStrResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemaStrResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetSchemaStrResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetSchemaStrResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_schema_str_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemaStrResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetSchemaStrResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetSchemaStrResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemaStrResult(%+v)", *p)
}

type TableGetSchemaStrWithIdsArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewTableGetSchemaStrWithIdsArgs() *TableGetSchemaStrWithIdsArgs {
	return &TableGetSchemaStrWithIdsArgs{}
}

func (p *TableGetSchemaStrWithIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_schema_str_with_ids_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaStrWithIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaStrWithIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSchemaStrWithIdsArgs(%+v)", *p)
}

type TableGetSchemaStrWithIdsResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewTableGetSchemaStrWithIdsResult() *TableGetSchemaStrWithIdsResult {
	return &TableGetSchemaStrWithIdsResult{}
}

func (p *TableGetSchemaStrWithIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_schema_str_with_ids_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSchemaStrWithIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaStrWithIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableGetSchemaStrWithIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSchemaStrWithIdsResult(%+v)", *p)
}

type GetSchemaStrWithIdsArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewGetSchemaStrWithIdsArgs() *GetSchemaStrWithIdsArgs {
	return &GetSchemaStrWithIdsArgs{}
}

func (p *GetSchemaStrWithIdsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemaStrWithIdsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetSchemaStrWithIdsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetSchemaStrWithIdsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_schema_str_with_ids_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemaStrWithIdsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetSchemaStrWithIdsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetSchemaStrWithIdsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemaStrWithIdsArgs(%+v)", *p)
}

type GetSchemaStrWithIdsResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetSchemaStrWithIdsResult() *GetSchemaStrWithIdsResult {
	return &GetSchemaStrWithIdsResult{}
}

func (p *GetSchemaStrWithIdsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemaStrWithIdsResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetSchemaStrWithIdsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetSchemaStrWithIdsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_schema_str_with_ids_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemaStrWithIdsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetSchemaStrWithIdsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetSchemaStrWithIdsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemaStrWithIdsResult(%+v)", *p)
}

type TableGetSchemaArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewTableGetSchemaArgs() *TableGetSchemaArgs {
	return &TableGetSchemaArgs{}
}

func (p *TableGetSchemaArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSchemaArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableGetSchemaArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableGetSchemaArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_schema_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSchemaArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableGetSchemaArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSchemaArgs(%+v)", *p)
}

type TableGetSchemaResult struct {
	Success *Schema          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewTableGetSchemaResult() *TableGetSchemaResult {
	return &TableGetSchemaResult{}
}

func (p *TableGetSchemaResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSchemaResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewSchema()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *TableGetSchemaResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableGetSchemaResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_schema_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSchemaResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TableGetSchemaResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableGetSchemaResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSchemaResult(%+v)", *p)
}

type GetSchemaArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewGetSchemaArgs() *GetSchemaArgs {
	return &GetSchemaArgs{}
}

func (p *GetSchemaArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemaArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetSchemaArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetSchemaArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_schema_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemaArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetSchemaArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetSchemaArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemaArgs(%+v)", *p)
}

type GetSchemaResult struct {
	Success *Schema          `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetSchemaResult() *GetSchemaResult {
	return &GetSchemaResult{}
}

func (p *GetSchemaResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSchemaResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewSchema()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetSchemaResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetSchemaResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_schema_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSchemaResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSchemaResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetSchemaResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSchemaResult(%+v)", *p)
}

type GetTablesArgs struct {
	Ns Namespace `thrift:"ns,1"`
}

func NewGetTablesArgs() *GetTablesArgs {
	return &GetTablesArgs{}
}

func (p *GetTablesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTablesArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetTablesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_tables_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTablesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetTablesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTablesArgs(%+v)", *p)
}

type GetTablesResult struct {
	Success []string         `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetTablesResult() *GetTablesResult {
	return &GetTablesResult{}
}

func (p *GetTablesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTablesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem560 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem560 = v
		}
		p.Success = append(p.Success, _elem560)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetTablesResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetTablesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_tables_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTablesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTablesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetTablesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTablesResult(%+v)", *p)
}

type NamespaceGetListingArgs struct {
	Ns Namespace `thrift:"ns,1"`
}

func NewNamespaceGetListingArgs() *NamespaceGetListingArgs {
	return &NamespaceGetListingArgs{}
}

func (p *NamespaceGetListingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceGetListingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *NamespaceGetListingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_get_listing_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceGetListingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *NamespaceGetListingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceGetListingArgs(%+v)", *p)
}

type NamespaceGetListingResult struct {
	Success []*NamespaceListing `thrift:"success,0"`
	E       *ClientException    `thrift:"e,1"`
}

func NewNamespaceGetListingResult() *NamespaceGetListingResult {
	return &NamespaceGetListingResult{}
}

func (p *NamespaceGetListingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceGetListingResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*NamespaceListing, 0, size)
	for i := 0; i < size; i++ {
		_elem561 := NewNamespaceListing()
		if err := _elem561.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem561)
		}
		p.Success = append(p.Success, _elem561)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *NamespaceGetListingResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NamespaceGetListingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_get_listing_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceGetListingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceGetListingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceGetListingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceGetListingResult(%+v)", *p)
}

type GetListingArgs struct {
	Ns Namespace `thrift:"ns,1"`
}

func NewGetListingArgs() *GetListingArgs {
	return &GetListingArgs{}
}

func (p *GetListingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetListingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetListingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_listing_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetListingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetListingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetListingArgs(%+v)", *p)
}

type GetListingResult struct {
	Success []*NamespaceListing `thrift:"success,0"`
	E       *ClientException    `thrift:"e,1"`
}

func NewGetListingResult() *GetListingResult {
	return &GetListingResult{}
}

func (p *GetListingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetListingResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*NamespaceListing, 0, size)
	for i := 0; i < size; i++ {
		_elem562 := NewNamespaceListing()
		if err := _elem562.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem562)
		}
		p.Success = append(p.Success, _elem562)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetListingResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetListingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_listing_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetListingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetListingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetListingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetListingResult(%+v)", *p)
}

type TableGetSplitsArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewTableGetSplitsArgs() *TableGetSplitsArgs {
	return &TableGetSplitsArgs{}
}

func (p *TableGetSplitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSplitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableGetSplitsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *TableGetSplitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_splits_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableGetSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *TableGetSplitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSplitsArgs(%+v)", *p)
}

type TableGetSplitsResult struct {
	Success []*TableSplit    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewTableGetSplitsResult() *TableGetSplitsResult {
	return &TableGetSplitsResult{}
}

func (p *TableGetSplitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableGetSplitsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TableSplit, 0, size)
	for i := 0; i < size; i++ {
		_elem563 := NewTableSplit()
		if err := _elem563.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem563)
		}
		p.Success = append(p.Success, _elem563)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TableGetSplitsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableGetSplitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_get_splits_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableGetSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TableGetSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableGetSplitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableGetSplitsResult(%+v)", *p)
}

type GetTableSplitsArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
}

func NewGetTableSplitsArgs() *GetTableSplitsArgs {
	return &GetTableSplitsArgs{}
}

func (p *GetTableSplitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableSplitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *GetTableSplitsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *GetTableSplitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_table_splits_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *GetTableSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *GetTableSplitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableSplitsArgs(%+v)", *p)
}

type GetTableSplitsResult struct {
	Success []*TableSplit    `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewGetTableSplitsResult() *GetTableSplitsResult {
	return &GetTableSplitsResult{}
}

func (p *GetTableSplitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableSplitsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TableSplit, 0, size)
	for i := 0; i < size; i++ {
		_elem564 := NewTableSplit()
		if err := _elem564.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem564)
		}
		p.Success = append(p.Success, _elem564)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetTableSplitsResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *GetTableSplitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_table_splits_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetTableSplitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableSplitsResult(%+v)", *p)
}

type NamespaceDropArgs struct {
	Ns       string `thrift:"ns,1"`
	IfExists bool   `thrift:"if_exists,2"`
}

func NewNamespaceDropArgs() *NamespaceDropArgs {
	return &NamespaceDropArgs{
		IfExists: true,
	}
}

func (p *NamespaceDropArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceDropArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *NamespaceDropArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.IfExists = v
	}
	return nil
}

func (p *NamespaceDropArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_drop_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceDropArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *NamespaceDropArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("if_exists", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:if_exists: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IfExists)); err != nil {
		return fmt.Errorf("%T.if_exists (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:if_exists: %s", p, err)
	}
	return err
}

func (p *NamespaceDropArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceDropArgs(%+v)", *p)
}

type NamespaceDropResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewNamespaceDropResult() *NamespaceDropResult {
	return &NamespaceDropResult{}
}

func (p *NamespaceDropResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NamespaceDropResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *NamespaceDropResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("namespace_drop_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NamespaceDropResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *NamespaceDropResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NamespaceDropResult(%+v)", *p)
}

type DropNamespaceArgs struct {
	Ns       string `thrift:"ns,1"`
	IfExists bool   `thrift:"if_exists,2"`
}

func NewDropNamespaceArgs() *DropNamespaceArgs {
	return &DropNamespaceArgs{
		IfExists: true,
	}
}

func (p *DropNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DropNamespaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = v
	}
	return nil
}

func (p *DropNamespaceArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.IfExists = v
	}
	return nil
}

func (p *DropNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("drop_namespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DropNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *DropNamespaceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("if_exists", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:if_exists: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IfExists)); err != nil {
		return fmt.Errorf("%T.if_exists (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:if_exists: %s", p, err)
	}
	return err
}

func (p *DropNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DropNamespaceArgs(%+v)", *p)
}

type DropNamespaceResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewDropNamespaceResult() *DropNamespaceResult {
	return &DropNamespaceResult{}
}

func (p *DropNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DropNamespaceResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *DropNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("drop_namespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DropNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *DropNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DropNamespaceResult(%+v)", *p)
}

type RenameTableArgs struct {
	Ns      Namespace `thrift:"ns,1"`
	Name    string    `thrift:"name,2"`
	NewName string    `thrift:"new_name,3"`
}

func NewRenameTableArgs() *RenameTableArgs {
	return &RenameTableArgs{}
}

func (p *RenameTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RenameTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *RenameTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *RenameTableArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.NewName = v
	}
	return nil
}

func (p *RenameTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rename_table_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RenameTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *RenameTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *RenameTableArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("new_name", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:new_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.NewName)); err != nil {
		return fmt.Errorf("%T.new_name (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:new_name: %s", p, err)
	}
	return err
}

func (p *RenameTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RenameTableArgs(%+v)", *p)
}

type RenameTableResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewRenameTableResult() *RenameTableResult {
	return &RenameTableResult{}
}

func (p *RenameTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RenameTableResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *RenameTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rename_table_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RenameTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *RenameTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RenameTableResult(%+v)", *p)
}

type TableRenameArgs struct {
	Ns      Namespace `thrift:"ns,1"`
	Name    string    `thrift:"name,2"`
	NewName string    `thrift:"new_name,3"`
}

func NewTableRenameArgs() *TableRenameArgs {
	return &TableRenameArgs{}
}

func (p *TableRenameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableRenameArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableRenameArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *TableRenameArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.NewName = v
	}
	return nil
}

func (p *TableRenameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_rename_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableRenameArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableRenameArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *TableRenameArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("new_name", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:new_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.NewName)); err != nil {
		return fmt.Errorf("%T.new_name (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:new_name: %s", p, err)
	}
	return err
}

func (p *TableRenameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableRenameArgs(%+v)", *p)
}

type TableRenameResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewTableRenameResult() *TableRenameResult {
	return &TableRenameResult{}
}

func (p *TableRenameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableRenameResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableRenameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_rename_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableRenameResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableRenameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableRenameResult(%+v)", *p)
}

type DropTableArgs struct {
	Ns       Namespace `thrift:"ns,1"`
	Name     string    `thrift:"name,2"`
	IfExists bool      `thrift:"if_exists,3"`
}

func NewDropTableArgs() *DropTableArgs {
	return &DropTableArgs{
		IfExists: true,
	}
}

func (p *DropTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DropTableArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *DropTableArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *DropTableArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.IfExists = v
	}
	return nil
}

func (p *DropTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("drop_table_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DropTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *DropTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *DropTableArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("if_exists", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:if_exists: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IfExists)); err != nil {
		return fmt.Errorf("%T.if_exists (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:if_exists: %s", p, err)
	}
	return err
}

func (p *DropTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DropTableArgs(%+v)", *p)
}

type DropTableResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewDropTableResult() *DropTableResult {
	return &DropTableResult{}
}

func (p *DropTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DropTableResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *DropTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("drop_table_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DropTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *DropTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DropTableResult(%+v)", *p)
}

type TableDropArgs struct {
	Ns       Namespace `thrift:"ns,1"`
	Name     string    `thrift:"name,2"`
	IfExists bool      `thrift:"if_exists,3"`
}

func NewTableDropArgs() *TableDropArgs {
	return &TableDropArgs{
		IfExists: true,
	}
}

func (p *TableDropArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableDropArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *TableDropArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *TableDropArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.IfExists = v
	}
	return nil
}

func (p *TableDropArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_drop_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableDropArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *TableDropArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *TableDropArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("if_exists", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:if_exists: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IfExists)); err != nil {
		return fmt.Errorf("%T.if_exists (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:if_exists: %s", p, err)
	}
	return err
}

func (p *TableDropArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableDropArgs(%+v)", *p)
}

type TableDropResult struct {
	E *ClientException `thrift:"e,1"`
}

func NewTableDropResult() *TableDropResult {
	return &TableDropResult{}
}

func (p *TableDropResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableDropResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *TableDropResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("table_drop_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TableDropResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *TableDropResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableDropResult(%+v)", *p)
}

type GenerateGuidArgs struct {
}

func NewGenerateGuidArgs() *GenerateGuidArgs {
	return &GenerateGuidArgs{}
}

func (p *GenerateGuidArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GenerateGuidArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("generate_guid_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GenerateGuidArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GenerateGuidArgs(%+v)", *p)
}

type GenerateGuidResult struct {
	Success string `thrift:"success,0"`
}

func NewGenerateGuidResult() *GenerateGuidResult {
	return &GenerateGuidResult{}
}

func (p *GenerateGuidResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GenerateGuidResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GenerateGuidResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("generate_guid_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GenerateGuidResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GenerateGuidResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GenerateGuidResult(%+v)", *p)
}

type CreateCellUniqueArgs struct {
	Ns        Namespace `thrift:"ns,1"`
	TableName string    `thrift:"table_name,2"`
	Key       *Key      `thrift:"key,3"`
	Value     string    `thrift:"value,4"`
}

func NewCreateCellUniqueArgs() *CreateCellUniqueArgs {
	return &CreateCellUniqueArgs{}
}

func (p *CreateCellUniqueArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateCellUniqueArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Ns = Namespace(v)
	}
	return nil
}

func (p *CreateCellUniqueArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.TableName = v
	}
	return nil
}

func (p *CreateCellUniqueArgs) readField3(iprot thrift.TProtocol) error {
	p.Key = NewKey()
	if err := p.Key.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Key)
	}
	return nil
}

func (p *CreateCellUniqueArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *CreateCellUniqueArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("create_cell_unique_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateCellUniqueArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ns", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ns: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Ns)); err != nil {
		return fmt.Errorf("%T.ns (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ns: %s", p, err)
	}
	return err
}

func (p *CreateCellUniqueArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table_name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:table_name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.TableName)); err != nil {
		return fmt.Errorf("%T.table_name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:table_name: %s", p, err)
	}
	return err
}

func (p *CreateCellUniqueArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:key: %s", p, err)
		}
		if err := p.Key.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Key)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:key: %s", p, err)
		}
	}
	return err
}

func (p *CreateCellUniqueArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *CreateCellUniqueArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateCellUniqueArgs(%+v)", *p)
}

type CreateCellUniqueResult struct {
	Success string           `thrift:"success,0"`
	E       *ClientException `thrift:"e,1"`
}

func NewCreateCellUniqueResult() *CreateCellUniqueResult {
	return &CreateCellUniqueResult{}
}

func (p *CreateCellUniqueResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateCellUniqueResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *CreateCellUniqueResult) readField1(iprot thrift.TProtocol) error {
	p.E = NewClientException()
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E)
	}
	return nil
}

func (p *CreateCellUniqueResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("create_cell_unique_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.E != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateCellUniqueResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *CreateCellUniqueResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.E != nil {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *CreateCellUniqueResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateCellUniqueResult(%+v)", *p)
}

type ErrorGetTextArgs struct {
	ErrorCode int32 `thrift:"error_code,1"`
}

func NewErrorGetTextArgs() *ErrorGetTextArgs {
	return &ErrorGetTextArgs{}
}

func (p *ErrorGetTextArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ErrorGetTextArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ErrorCode = v
	}
	return nil
}

func (p *ErrorGetTextArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("error_get_text_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ErrorGetTextArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("error_code", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:error_code: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ErrorCode)); err != nil {
		return fmt.Errorf("%T.error_code (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:error_code: %s", p, err)
	}
	return err
}

func (p *ErrorGetTextArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ErrorGetTextArgs(%+v)", *p)
}

type ErrorGetTextResult struct {
	Success string `thrift:"success,0"`
}

func NewErrorGetTextResult() *ErrorGetTextResult {
	return &ErrorGetTextResult{}
}

func (p *ErrorGetTextResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ErrorGetTextResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *ErrorGetTextResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("error_get_text_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ErrorGetTextResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *ErrorGetTextResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ErrorGetTextResult(%+v)", *p)
}
